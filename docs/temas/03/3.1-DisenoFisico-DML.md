# **3.1 Dise√±o F√≠sico: Lenguaje DDL**

## **Introducci√≥n**

En este tema, despu√©s de haber aprendido sobre el dise√±o conceptual y l√≥gico de bases de datos, nos adentraremos en el dise√±o f√≠sico. Este es el paso final antes de implementar nuestra base de datos en un sistema gestor de bases de datos (SGBD) real.

**Repaso r√°pido de los modelos de datos:**

- **Modelo Conceptual**: Es el primer boceto, la visi√≥n de m√°s alto nivel. Aqu√≠ nos centramos en entender el negocio y sus reglas, identificando las principales entidades (como "Clientes", "Productos", "Pedidos") y c√≥mo se relacionan entre ellas. Una herramienta muy com√∫n en esta fase es el **Diagrama Entidad-Relaci√≥n (ERD)**. El objetivo es que cualquier persona, t√©cnica o no, pueda entenderlo.

- **Modelo L√≥gico**: Este es el plano detallado. Transformamos las entidades y relaciones del modelo conceptual en una estructura m√°s formal, como tablas, columnas y claves. Sin embargo, en esta fase todav√≠a no pensamos en un sistema gestor de bases de datos (SGBD) espec√≠fico. Definimos los tipos de datos de forma gen√©rica (por ejemplo, "texto", "n√∫mero entero") y establecemos las relaciones a trav√©s de claves primarias y for√°neas.

- **Modelo F√≠sico**: ¬°Aqu√≠ es donde ponemos los cimientos de nuestra "casa digital"! El modelo f√≠sico es la implementaci√≥n real del modelo l√≥gico en un SGBD concreto, como MySQL, PostgreSQL, Oracle, etc. En esta fase, tomamos decisiones t√©cnicas importantes:
    - Traducimos los tipos de datos gen√©ricos a los tipos espec√≠ficos que ofrece nuestro SGBD (por ejemplo, `VARCHAR(100)` en lugar de "texto").
    - Definimos √≠ndices para acelerar las consultas.
    - Consideramos aspectos de rendimiento, almacenamiento y seguridad.
    - Finalmente, escribimos el c√≥digo para crear toda esta estructura.

El lenguaje que usamos para crear y gestionar la estructura de la base de datos en el modelo f√≠sico es el **SQL**.

## **¬øQu√© es SQL?**

SQL (Structured Query Language o Lenguaje de Consulta Estructurado) es el lenguaje est√°ndar utilizado para comunicarnos con las bases de datos relacionales. A pesar de ser un est√°ndar, cada SGBD tiene sus propias peque√±as variaciones o extensiones, lo que se conoce como "dialectos".

**Versiones m√°s importantes del est√°ndar SQL:**

- **SQL-86**: La primera versi√≥n estandarizada por ANSI.
- **SQL-92 (SQL2)**: Una revisi√≥n muy importante que introdujo muchas de las caracter√≠sticas que consideramos est√°ndar hoy en d√≠a.
- **SQL:1999 (SQL3)**: A√±adi√≥ expresiones regulares, triggers y tipos de datos m√°s avanzados.
- **Versiones posteriores (2003, 2008, 2011, 2016, 2023...)**: Han ido a√±adiendo funcionalidades como funciones de ventana (window functions), mejor soporte para XML y JSON, y otras caracter√≠sticas avanzadas.

Dentro de SQL, podemos agrupar las sentencias en cuatro sublenguajes principales:

- **DDL (Data Definition Language - Lenguaje de Definici√≥n de Datos)**: Se utiliza para definir y gestionar la estructura de la base de datos. Comandos como `CREATE`, `ALTER` y `DROP` pertenecen a este grupo. Es el protagonista de nuestro tema de hoy.
- **DML (Data Manipulation Language - Lenguaje de Manipulaci√≥n de Datos)**: Permite insertar, actualizar, borrar y modificar los datos almacenados en las tablas. Los comandos principales son `INSERT`, `UPDATE` y `DELETE`.
- **DQL (Data Query Language - Lenguaje de Consulta de Datos)**: Su principal y casi √∫nico comando es `SELECT`. Se utiliza para recuperar datos de la base de datos.
- **DCL (Data Control Language - Lenguaje de Control de Datos)**: Se encarga de la seguridad y la gesti√≥n de permisos de los usuarios sobre la base de datos. Incluye comandos como `GRANT` (conceder permisos) y `REVOKE` (revocar permisos).

### Sintaxis b√°sica de SQL

La sintaxis de SQL est√° compuesta por una serie de instrucciones que tienen diferentes par√°metros, unos obligatorios y otros opcionales. Para la expliacion de la sintaxis, se utilizar√° la siguiente convenci√≥n:

| **S√≠mbolo** | **Descripci√≥n** |
| --- | --- |
| May√∫sculas | Indican palabras reservadas del lenguaje. |
| Min√∫sculas | Indican elementos definidos por el usuario. |
| `[]` | Indica que el elemento es opcional. |
| `{}` | Indica que se debe elegir una opci√≥n. |
| `|` | Indica una alternativa entre opciones. |
| `...` | Indica que el elemento puede repetirse. |

!!! example "Ejemplo de sintaxis SQL"
    ```sql
      CREATE TABLE nombre_tabla (
        nombre_columna tipo_dato [CONSTRAINT restricci√≥n] ...,
        ...
        [CONSTRAINT restricci√≥n_tabla]
      );
    ```

Tenemos que destacar que cada instrucci√≥n SQL debe terminar con un punto y coma (`;`), que indica el final de la instrucci√≥n.

### Case sensitive

SQL no es sensible a may√∫sculas y min√∫sculas en las palabras reservadas, pero s√≠ lo es en los nombres de tablas y columnas, dependiendo del sistema de gesti√≥n de bases de datos (SGBD) utilizado. Por ejemplo, en MySQL, los nombres de tablas son sensibles a may√∫sculas y min√∫sculas en sistemas operativos que distinguen entre ellas (como Linux), mientras que en Windows no lo son. Es importante tener en cuenta estas diferencias al dise√±ar y consultar bases de datos para evitar errores inesperados.

| Elemento | Windows (por defecto) | Linux (por defecto) |
| --- | --- | --- |
| **Nombre de BD** | No distingue may√∫sculas/min√∫sculas | Distingue may√∫sculas/min√∫sculas |
| **Nombre de tabla** | No distingue may√∫sculas/min√∫sculas | Distingue may√∫sculas/min√∫sculas |
| **Nombre de columna / alias** | No distingue may√∫sculas/min√∫sculas | No distingue may√∫sculas/min√∫sculas |
| **Cadenas en consultas (`WHERE`)** | Depende de la `collation` | Depende de la `collation` |

!!! tip "Recomendaci√≥n"

	Para evitar problemas de compatibilidad y confusi√≥n, es recomendable **utilizar un estilo consistente para los nombres de tablas y columnas**, como todo en min√∫sculas o todo en may√∫sculas, y evitar el uso de espacios o caracteres especiales. **Normalmente, aquellas palabras reservadas de SQL se escriben en may√∫sculas para diferenciarlas de los nombres definidos por el usuario que est√°n en min√∫sculas**.

### Tipos de Datos: La base de todo

Antes de pasar a la definici√≥n de tablas, es importante entender los tipos de datos que se pueden utilizar en una base de datos relacional. Los tipos de datos definen la naturaleza de los datos que se almacenan en una columna espec√≠fica.

Elegir el tipo de dato correcto es una de las decisiones m√°s importantes en el dise√±o f√≠sico. Afecta al almacenamiento, al rendimiento y a la integridad de los datos.

Aqu√≠ ten√©is una tabla comparativa con algunos de los tipos de datos m√°s comunes en MySQL y PostgreSQL:

| Categor√≠a | Tipo en MySQL | Tipo en PostgreSQL | Descripci√≥n | Cu√°ndo usarlo |
| :--- | :--- | :--- | :--- | :--- |
| **Enteros** | `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT` | `SMALLINT`, `INTEGER`, `BIGINT` | N√∫meros enteros sin decimales. | Contadores, identificadores, cantidades (unidades de stock). |
| **Decimales** | `DECIMAL`, `NUMERIC` | `NUMERIC`, `DECIMAL` | N√∫meros con una precisi√≥n y escala fijas. | Valores monetarios, c√°lculos financieros, donde la exactitud es cr√≠tica. |
| **Flotantes** | `FLOAT`, `DOUBLE` | `REAL`, `DOUBLE PRECISION` | N√∫meros con decimales de precisi√≥n aproximada. | C√°lculos cient√≠ficos, mediciones donde una peque√±a imprecisi√≥n es aceptable. |
| **Cadenas de Texto** | `CHAR`, `VARCHAR`, `TEXT` | `CHAR`, `VARCHAR`, `TEXT` | Secuencias de caracteres. `CHAR` es de longitud fija, `VARCHAR` de longitud variable. | Nombres, direcciones, descripciones, cualquier tipo de texto. |
| **Binarios** | `BINARY`, `VARBINARY`, `BLOB` | `BYTEA` | Datos binarios en crudo. | Almacenar ficheros, im√°genes, datos encriptados directamente en la BD. |
| **Fecha y Hora** | `DATE`, `TIME`, `DATETIME`, `TIMESTAMP`, `YEAR` | `DATE`, `TIME`, `TIMESTAMP` | Para almacenar fechas, horas o combinaciones de ambas. | Fechas de nacimiento, fechas de registro, marcas de tiempo de eventos. |
| **Booleanos** | `BOOL`, `BOOLEAN` (alias de `TINYINT(1)`) | `BOOLEAN` | Representa valores verdadero (`TRUE`) o falso (`FALSE`). | Flags o indicadores de estado (ej: `es_activo`, `tiene_descuento`). |
| **Enumerados** | `ENUM` | `ENUM` (se crea como un tipo aparte) | Permite definir una lista de valores predefinidos para una columna. | D√≠as de la semana, estados de un pedido ('pendiente', 'enviado', 'entregado'). |
| **Geom√©tricos** | `GEOMETRY`, `POINT`, etc. | `POINT`, `LINE`, `POLYGON`, etc. | Tipos de datos para almacenar informaci√≥n espacial. | Mapas, geolocalizaci√≥n, GIS. |


Se puede consultar la documentaci√≥n oficial de cada SGBD para obtener informaci√≥n m√°s detallada sobre los tipos de datos y sus caracter√≠sticas espec√≠ficas: [MySQL](https://dev.mysql.com/doc/refman/8.0/en/data-types.html), [Oracle](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html), [PostgreSQL](https://www.postgresql.org/docs/current/datatype.html) o [MariaDB](https://mariadb.com/kb/en/data-types/).

!!! note "Nota"

	```sql
	DECIMAL(5,2) -- 5 d√≠gitos en total, 2 decimales (ejemplo: 120.99)`
	```

!!! question  "¬øQue tipo de datos usar?"

	Una de las decisiones m√°s importantes al dise√±ar una base de datos es elegir el tipo de datos adecuado para cada columna. Esta elecci√≥n afecta el rendimiento, la integridad y la eficiencia del almacenamiento de datos. Ademas del tipo de datos, **es importante considerar el tama√±o y la precisi√≥n necesarios para cada columna**. Por ejemplo, si se espera almacenar n√∫meros enteros peque√±os, se puede utilizar `TINYINT` en lugar de `INT` para ahorrar espacio de almacenamiento.

---

#### Profundizando en las Categor√≠as de Datos

##### Cadenas de Texto

- **`CHAR(longitud)`**: Longitud fija. Si defines `CHAR(10)` y guardas "Hola", ocupar√° 10 caracteres (rellenando con espacios). Es m√°s r√°pido para datos de longitud siempre igual, como un c√≥digo postal o un DNI.
- **`VARCHAR(longitud)`**: Longitud variable. Si defines `VARCHAR(10)` y guardas "Hola", ocupar√° solo los 4 caracteres m√°s un peque√±o extra para guardar la longitud. Es ideal para la mayor√≠a de textos como nombres o direcciones.
- **`TEXT`**: Para textos largos como descripciones de productos o cuerpos de art√≠culos de un blog. No se especifica una longitud m√°xima en la definici√≥n. Sin embargo, puede tener limitaciones en cuanto a la manipulaci√≥n y el rendimiento en comparaci√≥n con VARCHAR.

!!! warning "Advertencia"

	Si queremos ordenar o buscar en una columna, es mejor usar `CHAR` o `VARCHAR`, ya que `TEXT` puede tener limitaciones en cuanto a la manipulaci√≥n y el rendimiento.

!!! note "Nota"

	En MySQL, el tama√±o m√°ximo de `VARCHAR` es 65,535 bytes, pero este l√≠mite depende del conjunto de caracteres utilizado y del tama√±o total de la fila. Por ejemplo, si se utiliza UTF-8, cada car√°cter puede ocupar hasta 3 bytes, lo que reduce el n√∫mero m√°ximo de caracteres que se pueden almacenar en una columna `VARCHAR`. `TEXT` puede almacenar hasta 65,535 bytes, pero no se puede indexar completamente, lo que puede afectar el rendimiento de las consultas. Y por √∫ltimo, `CHAR` puede almacenar hasta 255 caracteres.

#### N√∫meros

Los tipos de datos num√©ricos incluyen `TINYINT`, `SMALLINT`, `INT`, `BIGINT`, `FLOAT`, `DOUBLE` y `DECIMAL`. La elecci√≥n entre estos tipos depende de la naturaleza de los datos que se van a almacenar y de los requisitos de precisi√≥n. Algunas consideraciones importantes son:

- **TINYINT, SMALLINT, INT, BIGINT**: Se utilizan para almacenar n√∫meros enteros de diferentes rangos. La elecci√≥n entre estos tipos depende del rango de valores que se espera almacenar. Por ejemplo, `TINYINT` es adecuado para valores peque√±os (de -128 a 127), mientras que `BIGINT` es adecuado para valores muy grandes (de -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807). **"Nueve trillones doscientos veintitr√©s mil trescientos setenta y dos billones treinta y seis mil ochocientos cincuenta y cuatro millones setecientos setenta y cinco mil ochocientos siete."** üò•‚Äã
- **FLOAT, DOUBLE**: Se utilizan para almacenar n√∫meros de punto flotante. `FLOAT` es adecuado para valores con menor precisi√≥n, mientras que `DOUBLE` es adecuado para valores con mayor precisi√≥n. Sin embargo, ambos tipos **pueden introducir errores de redondeo debido a la naturaleza de los n√∫meros de punto flotante**.
- **DECIMAL**: Se utiliza para almacenar n√∫meros con una precisi√≥n exacta, como valores monetarios. `DECIMAL` permite especificar la precisi√≥n total y la cantidad de decimales, lo que lo hace adecuado para aplicaciones financieras **donde la exactitud es crucial**.

!!! info "Con signo o sin signo"

	**Signed vs Unsigned**: `SIGNED` (por defecto) permite n√∫meros negativos y positivos. `UNSIGNED` solo permite n√∫meros positivos (y el cero), duplicando el rango m√°ximo positivo. Es perfecto para claves primarias autoincrementales (`id`) que nunca ser√°n negativas.

| Tipo MySQL | Rango (Signed - con signo) | Rango (Unsigned - sin signo) |
| :--- | :--- | :--- |
| **`TINYINT`** | -128 a 127 | 0 a 255 |
| **`SMALLINT`** | -32,768 a 32,767 | 0 a 65,535 |
| **`MEDIUMINT`**| -8,388,608 a 8,388,607 | 0 a 16,777,215 |
| **`INT`** | -2,147,483,648 a 2,147,483,647 | 0 a 4,294,967,295 |
| **`BIGINT`** | -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 | 0 a 18,446,744,073,709,551,615 |


#### Fechas y Horas

Los tipos de datos para fechas y horas incluyen `DATE`, `TIME`, `DATETIME` y `TIMESTAMP`. La elecci√≥n entre estos tipos depende de la naturaleza de los datos que se van a almacenar y de los requisitos de precisi√≥n.

- **`DATE`**: Almacena una fecha (a√±o, mes, d√≠a). Formato: `YYYY-MM-DD`. Por ejemplo, `DATE` almacena valores en el formato 'YYYY-MM-DD', como '2023-10-15'.
- **`TIME`**: Almacena una hora (horas, minutos, segundos). Formato: `HH:MM:SS`.Por ejemplo, `TIME` almacena valores en el formato 'HH:MM:SS', como '14:30:00'.
- **`DATETIME`**: Combina fecha y hora. Formato: `YYYY-MM-DD HH:MM:SS`.Por ejemplo, `DATETIME` almacena valores en el formato 'YYYY-MM-DD HH:MM:SS', como '2023-10-15 14:30:00'.
- **`TIMESTAMP`**: Similar a `DATETIME`, pero con un rango m√°s limitado (desde 1970 hasta 2038). Tiene la particularidad de que se puede configurar para que se actualice autom√°ticamente a la fecha y hora actual cada vez que la fila es modificada (`ON UPDATE CURRENT_TIMESTAMP`). Muy √∫til para campos como `fecha_modificacion`. Por ejemplo, `TIMESTAMP` almacena valores en el formato 'YYYY-MM-DD HH:MM:SS', pero **se convierte autom√°ticamente a la zona horaria del servidor**.

#### Enumerados (`ENUM`)

Permite que una columna solo pueda tomar uno de los valores de una lista que t√∫ defines. Por ejemplo: `estado ENUM('activo', 'inactivo', 'pendiente')`. Internamente, MySQL lo almacena como un n√∫mero (1, 2, 3), lo que lo hace muy eficiente, pero muestra el texto que le corresponde, lo cual es muy legible.

```sql
estado ENUM('activo', 'inactivo', 'pendiente')
```

!!! warning "Advertencia"

	Este tipo de datos **no est√° definido en el est√°ndar SQL**, por lo que no es soportado por todos los SGBD. Esto produce problemas de portabilidad si se quiere migrar la base de datos a otro SGBD. Se recomienda usar restricciones `CHECK` en su lugar para asegurar la integridad de los datos.


#### El valor `NULL`

El valor `NULL` en SQL representa la ausencia de un valor o un valor desconocido. Es importante entender que `NULL` no es lo mismo que cero (0) o una cadena vac√≠a (''). En SQL, `NULL` se utiliza para indicar que un campo no tiene ning√∫n valor asignado.

Cuando se define una columna en una tabla, se puede especificar si esa columna permite valores `NULL` o no. Por defecto, las columnas permiten valores `NULL`, pero se puede cambiar este comportamiento utilizando la restricci√≥n `NOT NULL`.


---

## **DDL: Data Definition Language**

El lenguaje de definici√≥n de datos (DDL) se utiliza para definir y modificar la estructura de una base de datos. Los comandos DDL m√°s comunes son:

- `CREATE`: Se utiliza para crear nuevas tablas, bases de datos, √≠ndices y otros objetos en la base de datos.
- `ALTER`: Se utiliza para modificar la estructura de una tabla existente, como agregar, eliminar o modificar columnas.
- `DROP`: Se utiliza para eliminar tablas, bases de datos, √≠ndices y otros objetos de la base de datos.


### Instalaci√≥n de MySQL

Para el desarrollo de las pr√°cticas, se utilizar√° MySQL como sistema de gesti√≥n de bases de datos (SGBD). Puedes descargar e instalar **MySQL Community Server** desde su [p√°gina oficial](https://dev.mysql.com/downloads/mysql/). Durante la instalaci√≥n, aseg√∫rate de configurar una contrase√±a segura para el usuario `root`, ya que este usuario tiene privilegios administrativos completos en la base de datos.

Para interactuar con MySQL, puedes utilizar la l√≠nea de comandos de MySQL o una herramienta gr√°fica como **MySQL Workbench**, que tambi√©n est√° disponible en la p√°gina de descargas de MySQL. Puedes encontrar tutoriales y documentaci√≥n en l√≠nea para ayudarte a instalar y configurar MySQL seg√∫n tus necesidades.

### Base de datos

Antes de crear tablas, es necesario crear una base de datos donde se almacenar√°n dichas tablas. Para crear una base de datos en MySQL, se utiliza el comando `CREATE DATABASE` seguido del nombre que se desea asignar a la base de datos. Por ejemplo, para crear una base de datos llamada `mi_base_de_datos`, se utilizar√≠a la siguiente instrucci√≥n SQL:

```sql
CREATE [OR REPLACE] DATABASE [IF NOT EXISTS] mi_base_de_datos;
```

Podemos mostrar las bases de datos existentes con el comando:

```sql
SHOW DATABASES;
```

Y por otro lado, para eliminar una base de datos, se utiliza el comando `DROP DATABASE` seguido del nombre de la base de datos que se desea eliminar:

```sql
DROP DATABASE IF EXISTS mi_base_de_datos;
```

**Una vez creada la base de datos, es necesario seleccionarla para poder trabajar con ella**. Esto se hace con el comando `USE` seguido del nombre de la base de datos:

```sql
USE mi_base_de_datos;
```

### Jerarqu√≠a de almacenamiento

La jerarqu√≠a de almacenamiento de datos se organiza en varios niveles, desde el m√°s general hasta el m√°s espec√≠fico. A continuaci√≥n, se describe esta jerarqu√≠a con independencia del SGBD utilizado:

- **Tablespace**: Es una estructura f√≠sica de almacenamiento que agrupa varios archivos de datos. Un tablespace puede contener m√∫ltiples bases de datos y es gestionado por el SGBD.
- **Base de datos**: Es un contenedor l√≥gico que agrupa varias tablas y otros objetos relacionados. Cada base de datos tiene su propio conjunto de tablas, vistas, √≠ndices y otros objetos.
- **Esquema (schema)**: Es una colecci√≥n de objetos de base de datos, como tablas, vistas, procedimientos almacenados, etc., que pertenecen a un usuario espec√≠fico. Un esquema ayuda a organizar y gestionar los objetos dentro de una base de datos. En MySQL, el esquema es sin√≥nimo de base de datos.
- **Tabla**: Es una estructura que almacena datos en filas y columnas. Cada tabla representa una entidad o concepto del mundo real y contiene datos relacionados.

### Motores de almacenamiento

En los sistemas de gesti√≥n de bases de datos (SGBD) como MySQL, **un motor de almacenamiento es el componente responsable de gestionar c√≥mo se almacenan, recuperan y manipulan los datos en las tablas**. MySQL soporta varios motores de almacenamiento, cada uno con sus propias caracter√≠sticas y ventajas. Algunos de los motores de almacenamiento m√°s comunes en MySQL son:

- **InnoDB**: Es el motor de almacenamiento predeterminado en MySQL. Soporta transacciones, claves for√°neas y bloqueo a nivel de fila, lo que lo hace adecuado para aplicaciones que requieren integridad referencial y concurrencia.
- **MyISAM**: Es un motor de almacenamiento m√°s antiguo que no soporta transacciones ni claves for√°neas. Es m√°s r√°pido para operaciones de lectura, pero menos eficiente para operaciones de escritura y no garantiza la integridad referencial.

Bloqueo a nivel de fila vs. tabla

- **Bloqueo a nivel de fila**: Permite que m√∫ltiples transacciones accedan y modifiquen diferentes filas de una tabla simult√°neamente, mejorando la concurrencia y el rendimiento en entornos con muchas operaciones de escritura.
- **Bloqueo a nivel de tabla**: Bloquea toda la tabla durante una operaci√≥n de escritura, lo que puede reducir la concurrencia y el rendimiento en entornos con muchas operaciones de escritura.

### Juego de caracteres y collation

Un juego de caracteres (character set) es un conjunto de caracteres que se utilizan para representar texto en una base de datos. Cada juego de caracteres tiene un conjunto espec√≠fico de caracteres y un esquema de codificaci√≥n asociado. Algunos juegos de caracteres comunes en MySQL son:

- **utf8mb4**: Es un juego de caracteres que soporta todos los caracteres Unicode, incluyendo emojis y otros caracteres especiales. Es el juego de caracteres recomendado para la mayor√≠a de las aplicaciones.
- **latin1**: Es un juego de caracteres que soporta caracteres occidentales y es m√°s eficiente en t√©rminos de almacenamiento para textos en idiomas como el ingl√©s, espa√±ol, franc√©s, etc.
- **ascii**: Es un juego de caracteres que soporta solo caracteres ASCII (caracteres b√°sicos en ingl√©s). Es el m√°s eficiente en t√©rminos de almacenamiento, pero no es adecuado para textos en otros idiomas.

Una collation es un conjunto de reglas que determinan c√≥mo se comparan y ordenan los caracteres en una base de datos. Cada juego de caracteres puede tener varias collations asociadas, que definen diferentes formas de comparar y ordenar los caracteres. Algunas collations comunes en MySQL son:

- **utf8mb4\_general\_ci**: Es una collation que realiza comparaciones y ordenaciones de manera insensible a may√∫sculas y min√∫sculas (case-insensitive) y no distingue entre acentos (accent-insensitive).
- **utf8mb4\_bin**: Es una collation que realiza comparaciones y ordenaciones basadas en el valor binario de los caracteres, lo que significa que es sensible a may√∫sculas y min√∫sculas (case-sensitive) y distingue entre acentos (accent-sensitive).

Nota

Por defecto, MySQL utiliza el juego de caracteres `latin1` y la collation `latin1_swedish_ci`. Sin embargo, es recomendable utilizar `utf8mb4` y una collation adecuada para garantizar la compatibilidad con una amplia gama de caracteres y evitar problemas de codificaci√≥n.

La siguiente sentencia SQL crea una base de datos llamada `mi_base_de_datos` con el juego de caracteres `utf8mb4` y la collation `utf8mb4_general_ci`, y selecciona dicha base de datos para su uso:

`CREATE DATABASE mi_base_de_datos     CHARACTER SET utf8mb4     COLLATE utf8mb4_general_ci;  USE mi_base_de_datos;`



### El Lenguaje DDL: Definiendo la estructura

Ahora que conocemos los materiales (los tipos de datos), vamos a aprender a construir la estructura (las tablas) con DDL.

#### `CREATE TABLE`: Creando la estructura

Para crear una tabla en una base de datos, se utiliza el comando `CREATE TABLE`. La sintaxis b√°sica para crear una tabla es la siguiente:

```sql
CREATE [OR REPLACE] TABLE [base_de_datos.]nombre_tabla (
    columna1 tipo_dato1 [opciones],
    columna2 tipo_dato2 [opciones],
    ...
    [restricciones_tabla]
);
```

Debemos tener algunas consideraciones al crear tablas:

- **Nombres de tablas**: Los nombres de tablas deben ser √∫nicos dentro de una base de datos. No se deben utilizar espacios ni caracteres especiales en los nombres de tablas. Ademas, no se deben utilizar palabras reservadas de SQL como nombres de tablas. Es recomendable utilizar nombres descriptivos y consistentes para facilitar la comprensi√≥n y el mantenimiento de la base de datos

Algunos ejemplos de creacion de tablas con diferentes tipos de datos y restricciones:

```sql
CREATE TABLE productos (
    id_producto INT PRIMARY KEY AUTO_INCREMENT,
    nombre VARCHAR(100) NOT NULL,
    precio DECIMAL(10,2) NOT NULL,
    stock INT DEFAULT 0,
    fecha_creacion DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE empleados (
    id_empleado INT PRIMARY KEY AUTO_INCREMENT,
    nombre VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    fecha_contratacion DATE NOT NULL,
    salario DECIMAL(10,2) CHECK (salario >= 0)
);
```

#### Claves primaria

Una clave primaria (Primary Key, PK) es una columna o conjunto de columnas que identifica de manera √∫nica cada fila en una tabla. Las claves primarias tienen las siguientes caracter√≠sticas:

- **Unicidad**: Cada valor de clave primaria debe ser √∫nico en la tabla. No puede haber dos filas con el mismo valor de clave primaria.
- **No nulo**: Los valores de clave primaria no pueden ser `NULL`. Cada fila debe tener un valor v√°lido para la clave primaria.
- **√çndice**: Las claves primarias crean autom√°ticamente un √≠ndice √∫nico en la columna o columnas que las componen, lo que mejora el rendimiento de las consultas que utilizan la clave primaria.
- **Inmutabilidad**: Los valores de clave primaria no deben cambiar una vez asignados. Cambiar el valor de una clave primaria puede causar problemas de integridad referencial en la base de datos.
- **Simplicidad**: Es recomendable que las claves primarias sean simples y f√°ciles de manejar. Evitar el uso de claves compuestas (claves primarias que consisten en m√∫ltiples columnas) a menos que sea absolutamente necesario.
- **Auto-incremento**: En muchos casos, las claves primarias se definen como columnas de tipo entero con la opci√≥n `AUTO_INCREMENT`, lo que permite que el SGBD genere autom√°ticamente un valor √∫nico para cada nueva fila insertada en la tabla.
- **Elecci√≥n del tipo de dato**: Es importante elegir un tipo de dato adecuado para la clave primaria, considerando el rango de valores que se espera almacenar y el tama√±o del almacenamiento. Por ejemplo, si se espera almacenar un gran n√∫mero de filas, es recomendable utilizar `BIGINT` en lugar de `INT`.

Existen muchas formas de definir una clave primaria en una tabla. Dependiendo de d√≥nde se coloque la restricci√≥n `PRIMARY KEY`, la sintaxis puede variar ligeramente. A continuaci√≥n, se muestran algunos ejemplos de c√≥mo definir una clave primaria en una tabla:

```sql
CREATE TABLE clientes (
    id_cliente INT PRIMARY KEY AUTO_INCREMENT,
    nombre VARCHAR(100) NOT NULL
);

CREATE TABLE productos (
    id_producto INT NOT NULL AUTO_INCREMENT,
    nombre VARCHAR(100) NOT NULL,
    precio DECIMAL(10,2) NOT NULL,
    PRIMARY KEY (id_producto)
);

CREATE TABLE empleados (
    id_empleado INT,
    nombre VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    fecha_contratacion DATE NOT NULL,
    salario DECIMAL(10,2) CHECK (salario >= 0),
    CONSTRAINT pk_empleados PRIMARY KEY (id_empleado)
);

CREATE TABLE ordenes (
    id_orden INT,
    id_cliente INT,
    fecha DATETIME NOT NULL,
    total DECIMAL(10,2) NOT NULL,
    PRIMARY KEY (id_orden, id_cliente) -- Clave primaria compuesta
);
```

!!! info "Resumen de creaci√≥n de tablas"

	Tabla resumen con diferente formas de crear tablas con claves primarias y otras opciones:

	| Sintaxis / Variante | Ejemplo | Descripci√≥n |
	| :--- | :--- | :--- |
	| **Creaci√≥n b√°sica** | `CREATE TABLE Empleados (id INT, nombre VARCHAR(100), fecha_contrato DATE);` | Crea una tabla simple con tres columnas y sus tipos de datos. |
	| **Con Clave Primaria (PK)** | `CREATE TABLE Empleados (id INT PRIMARY KEY, nombre VARCHAR(100));` | Define la columna `id` como clave primaria en la misma l√≠nea. |
	| **PK Separada** | `CREATE TABLE Empleados (id INT, nombre VARCHAR(100), PRIMARY KEY(id));` | Define la clave primaria al final de la definici√≥n de columnas. Obligatorio para PK compuestas. |
	| **PK Compuesta** | `CREATE TABLE Pedido_Detalle (id_pedido INT, id_producto INT, cantidad INT, PRIMARY KEY(id_pedido, id_producto));` | Crea una clave primaria formada por dos o m√°s columnas. |
	| **Con valor por defecto** | `CREATE TABLE Productos (id INT, nombre VARCHAR(50), stock INT DEFAULT 0);` | Si no se especifica un valor para `stock` al insertar una fila, se usar√° `0` por defecto. |
	| **Con autoincremento** | `CREATE TABLE Categorias (id INT PRIMARY KEY AUTO_INCREMENT, nombre VARCHAR(50));` | El SGBD asignar√° autom√°ticamente un valor num√©rico secuencial a la columna `id` en cada nueva inserci√≥n. |


#### Modificaci√≥n de tablas


Para modificar la estructura de una tabla existente, se utiliza el comando `ALTER TABLE`. La sintaxis b√°sica para modificar una tabla es la siguiente:

```sql
ALTER TABLE [base_de_datos.]nombre_tabla
    {ADD columna tipo_dato [opciones] [FIRST | AFTER nombreColumna] |
     DROP columna |
     MODIFY columna tipo_dato [opciones] |

     ADD CONSTRAINT restricci√≥n_tabla};
```

Si queremos a√±adir una columna a una tabla usaremos `ADD`, por ejemplo:

```sql
ALTER TABLE clientes
	ADD email VARCHAR(100) NOT NULL AFTER nombre;
```

<small>*`FIRST` y `AFTER` se utilizan para especificar la posici√≥n de la nueva columna en la tabla. Si no se especifica ninguna de estas opciones, la nueva columna se a√±adir√° al final de la tabla.*</small>

Si lo que queremos es modificar una columna existente, usaremos `MODIFY`, por ejemplo:

```sql
ALTER TABLE clientes
    MODIFY nombre VARCHAR(150);
```

!!! note "Nota"

	Modificar una columna implica volver a definir el tipo de dato y las opciones de la columna.

En el caso de que queramos eliminar una columna, usaremos `DROP`, por ejemplo:

```sql
ALTER TABLE clientes
	DROP COLUMN email;
```

Podemos cambiar el nombre de una tabla utilizando `RENAME TO`, por ejemplo:

```sql
ALTER TABLE [base_de_datos.]nombre_tabla
    RENAME TO nuevo_nombre_tabla;
```

Para cambiar el nombre de una columna, usaremos `CHANGE`, por ejemplo:

```sql
ALTER TABLE clientes
    CHANGE email email_nuevo VARCHAR(100);
```
<small>*En el comando CHANGE, es necesario especificar el nombre actual de la columna seguido del nuevo nombre y el tipo de dato*.</small>



!!! tip "Resumen de modificaciones con ALTER TABLE"

	Resumen de las operaciones m√°s comunes con `ALTER TABLE`:

	| Operaci√≥n | Ejemplo | Descripci√≥n |
	| :--- | :--- | :--- |
	| **A√±adir columna** | `ALTER TABLE Empleados ADD COLUMN salario DECIMAL(10, 2);` | A√±ade una nueva columna llamada `salario` a la tabla `Empleados`. |
	| **Eliminar columna** | `ALTER TABLE Empleados DROP COLUMN fecha_contrato;` | Elimina la columna `fecha_contrato` y todos sus datos. ¬°Cuidado, esta acci√≥n es irreversible! |
	| **Renombrar columna** | `ALTER TABLE Empleados RENAME COLUMN nombre TO nombre_completo;` | Cambia el nombre de la columna `nombre` a `nombre_completo`. |
	| **Modificar tipo de dato** | `ALTER TABLE Empleados MODIFY COLUMN nombre_completo VARCHAR(150);` | Cambia el tipo de dato o la longitud de una columna existente. |
	| **A√±adir restricci√≥n** | `ALTER TABLE Empleados ADD CONSTRAINT uq_email UNIQUE (email);` | A√±ade una restricci√≥n de unicidad a la columna `email`. |
	| **Eliminar restricci√≥n** | `ALTER TABLE Empleados DROP CONSTRAINT uq_email;` | Elimina una restricci√≥n previamente creada. |

<br>

#### Borrado de tablas

Para eliminar una tabla de una base de datos, se utiliza el comando `DROP TABLE`. La sintaxis b√°sica para eliminar una tabla es la siguiente:

```sql
DROP TABLE [IF EXISTS] [base_de_datos.]nombre_tabla;
```

Como el borrado de una tabla implica la eliminaci√≥n de los registros, debemos tener en cuenta que en una base de datos relacional, las tablas pueden estar relacionadas entre s√≠ mediante claves for√°neas. Si intentamos eliminar una tabla que est√° siendo referenciada por otra tabla a trav√©s de una clave for√°nea, el SGBD puede impedir la eliminaci√≥n para mantener la integridad referencial. En estos casos, es necesario eliminar primero las relaciones de clave for√°nea antes de poder eliminar la tabla.

!!! tip "Resumen de borrado de tablas"

	Resumen de las operaciones m√°s comunes para borrar tablas:

	| Operaci√≥n | Ejemplo | Descripci√≥n |
	| :--- | :--- | :--- |
	| **Borrar tabla** | `DROP TABLE Empleados;` | Elimina permanentemente la tabla `Empleados`, su estructura y todos los datos que contiene. |
	| **Borrar si existe** | `DROP TABLE IF EXISTS Empleados;` | Igual que la anterior, pero no dar√° un error si la tabla no existe. Muy √∫til en scripts. |

---

### Restricciones (Constraints): Las reglas del juego

Las restricciones son reglas que aplicamos a las columnas de una tabla para garantizar la **integridad y la calidad de los datos**. Este tipo de restricciones se definen al momento de crear o modificar una tabla. A continuaci√≥n, se describen algunas de las restricciones m√°s comunes mediante la sintaxis SQL:

```sql
CREATE TABLE [db.]tabla (
    campo1 tipo_dato1 [NOT NULL | NULL] [DEFAULT valor],
    ...,

    [CONSTRAINT nombre_restriccion]
    [ENGINE = Innodb] -- motor de ejecuci√≥n
);
```

!!! tip "Recomendaci√≥n"

	Para mantener una estructura clara y legible, usaremos la definici√≥n de restricciones:

	- a nivel de columna, para restricciones simples como `DEFAULT`, `AUTO_INCREMENT` y `NOT NULL`.
	- mediante `CONSTRAINT`, para restricciones m√°s complejas como `PRIMARY KEY`, `FOREIGN KEY`, `CHECK` y `UNIQUE`.


Las restricciones pueden aplicarse a nivel de columna o a nivel de tabla. A nivel de columna, las restricciones se definen directamente en la definici√≥n de la columna. A nivel de tabla, las restricciones se definen al final de la definici√≥n de la tabla utilizando la palabra clave `CONSTRAINT`.


- **Clave √önica (`UNIQUE`)**: Asegura que todos los valores en una columna (o conjunto de columnas) sean √∫nicos. Por ejemplo, el DNI o el email de un usuario. Una tabla puede tener varias restricciones `UNIQUE`. A diferencia de la Clave Primaria, s√≠ puede contener un valor `NULL` (y varios, de hecho, en MySQL).

    ```sql
    CREATE TABLE Usuarios (
        id INT PRIMARY KEY AUTO_INCREMENT,
        email VARCHAR(100) UNIQUE,
        username VARCHAR(50) NOT NULL,
        CONSTRAINT uq_username UNIQUE (username) -- Otra forma de declararla
    );
    ```

- **Clave For√°nea (`FOREIGN KEY`)**: Es el mecanismo que nos permite relacionar tablas. Una clave for√°nea en una tabla (la tabla "hija") apunta a la clave primaria de otra tabla (la tabla "padre"). Esto garantiza la **integridad referencial**: no puedes tener un pedido para un cliente que no existe.

    **Creaci√≥n al definir la tabla:**
    ```sql
    CREATE TABLE Pedidos (
        id INT PRIMARY KEY AUTO_INCREMENT,
        fecha DATE,
        id_cliente INT,
        -- Opci√≥n 1: Sin nombre de constraint expl√≠cito
        FOREIGN KEY (id_cliente) REFERENCES Clientes(id)
    );

    CREATE TABLE LineasPedido (
        id INT PRIMARY KEY,
        id_pedido INT,
        id_producto INT,
        -- Opci√≥n 2: Dando un nombre a la constraint (recomendado)
        CONSTRAINT fk_linea_pedido FOREIGN KEY (id_pedido) REFERENCES Pedidos(id)
    );
    ```

    **Creaci√≥n en una tabla ya existente:**
    ```sql
    ALTER TABLE Pedidos
    ADD CONSTRAINT fk_pedidos_clientes
    FOREIGN KEY (id_cliente) REFERENCES Clientes(id);
    ```

#### Propagaci√≥n de acciones

Las acciones `ON DELETE` y `ON UPDATE` definen el comportamiento que se debe seguir cuando se elimina o actualiza un registro en la tabla referenciada. Las opciones disponibles son:

- **CASCADE**: Si se elimina o actualiza un registro en la tabla referenciada, se eliminar√°n o actualizar√°n autom√°ticamente los registros correspondientes en la tabla que contiene la clave for√°nea.
- **SET NULL**: Si se elimina o actualiza un registro en la tabla referenciada, los valores de la clave for√°nea en la tabla que contiene la clave for√°nea se establecer√°n en `NULL`.
- **NO ACTION**: No se permite la eliminaci√≥n o actualizaci√≥n del registro en la tabla referenciada si existen registros relacionados en la tabla que contiene la clave for√°nea. Esta es la opci√≥n predeterminada si no se especifica ninguna acci√≥n.
- **SET DEFAULT**: Si se elimina o actualiza un registro en la tabla referenciada, los valores de la clave for√°nea en la tabla que contiene la clave for√°nea se establecer√°n en su valor por defecto.
- **RESTRICT**: Similar a `NO ACTION`, pero la verificaci√≥n se realiza inmediatamente cuando se intenta eliminar o actualizar el registro en la tabla referenciada.

!!! note "Nota"

	La diferencia principal entre NO ACTION y RESTRICT es el momento en que se realiza la verificaci√≥n de integridad referencial. Con NO ACTION, la verificaci√≥n se realiza al final de una transacci√≥n, mientras que con RESTRICT, la verificaci√≥n se realiza inmediatamente.


- *Ejemplo con SET NULL*

	```sql
	CREATE TABLE Pedidos (
		id INT PRIMARY KEY AUTO_INCREMENT,
		fecha DATE,
		id_cliente INT,
		FOREIGN KEY (id_cliente) REFERENCES Clientes(id)
		ON DELETE SET NULL
		ON UPDATE CASCADE
	);
	```

- *Ejemplo con CASCADE*

	```sql
	CREATE TABLE LineasPedido (
		id INT PRIMARY KEY,
		id_pedido INT,
		id_producto INT,
		CONSTRAINT fk_linea_pedido FOREIGN KEY (id_pedido) REFERENCES Pedidos(id)
		ON DELETE CASCADE
		ON UPDATE CASCADE
	);
	```

- *Ejemplo con RESTRICT*

	```sql
	CREATE TABLE Comentarios (
		id INT PRIMARY KEY AUTO_INCREMENT,
		id_producto INT,
		comentario TEXT,
		FOREIGN KEY (id_producto) REFERENCES Productos(id)
		ON DELETE RESTRICT
		ON UPDATE RESTRICT
	);
	```


### Validaciones de datos

Las restricciones `CHECK` se utilizan para validar los datos que se insertan o actualizan en una tabla. Estas restricciones permiten definir condiciones que los valores de una columna o conjunto de columnas deben cumplir para ser aceptados en la tabla. Si un valor no cumple con la condici√≥n definida en la restricci√≥n `CHECK`, el SGBD rechazar√° la operaci√≥n de inserci√≥n o actualizaci√≥n y devolver√° un error.


```sql
CREATE TABLE empleados (
    id_empleado INT AUTO_INCREMENT,
    nombre VARCHAR(100),
    email VARCHAR(100),
    fecha_contratacion DATE,
    salario DECIMAL(10,2),

    CONSTRAINT pk_empleados PRIMARY KEY (id_empleado),
    CONSTRAINT ck_salario CHECK (salario >= 0) -- El salario debe ser mayor o igual a 0
);
```

De igual forma, podemos usar la restricci√≥n de verificaci√≥n para comparar valores entre varias columnas:

```sql
CREATE TABLE productos (
    id_producto INT AUTO_INCREMENT,
    nombre VARCHAR(100),
    precio DECIMAL(10,2),
    stock INT,

    CONSTRAINT pk_empleados PRIMARY KEY (id_producto),
    -- El precio y el stock deben ser mayores o iguales a 0
    CONSTRAINT chk_precio_stock CHECK (precio >= 0 AND stock >= 0) 
);
```

#### Entre un rango (BETWEEN)

La cl√°usula `BETWEEN` se utiliza en las restricciones `CHECK` para verificar si un valor se encuentra dentro de un rango espec√≠fico. La sintaxis b√°sica para utilizar `BETWEEN` en una restricci√≥n `CHECK` es la siguiente:

```sql
CONSTRAINT nombre_restriccion CHECK (columna BETWEEN valor_inferior AND valor_superior)
```

Ambos valores, el inferior y el superior, son inclusivos. Por ejemplo, si queremos asegurarnos de que la columna `edad` en una tabla `personas` est√© entre 0 y 120, podemos definir la restricci√≥n `CHECK` de la siguiente manera:

```sql
CREATE TABLE personas (
    id_persona INT AUTO_INCREMENT,
    nombre VARCHAR(100),
    edad INT,

    CONSTRAINT pk_personas PRIMARY KEY (id_persona),
    CONSTRAINT chk_edad CHECK (edad BETWEEN 0 AND 120) -- La edad debe estar entre 0 y 120
);
```

#### Conjunto de valores (IN)

La cl√°usula `IN` se utiliza en las restricciones `CHECK` para verificar si un valor pertenece a un conjunto espec√≠fico de valores. La sintaxis b√°sica para utilizar `IN` en una restricci√≥n `CHECK` es la siguiente:

```sql
CONSTRAINT nombre_restriccion CHECK (columna IN (valor1, valor2, valor3, ...))
```

Por ejemplo, si queremos asegurarnos de que la columna `genero` en una tabla `usuarios` solo contenga los valores 'M' (masculino), 'F' (femenino) o 'O' (otro), podemos definir la restricci√≥n `CHECK` de la siguiente manera:

```sql
CREATE TABLE usuarios (
    id_usuario INT AUTO_INCREMENT,
    nombre VARCHAR(100),
    genero CHAR(1),

    CONSTRAINT pk_usuarios PRIMARY KEY (id_usuario),
    CONSTRAINT chk_genero CHECK (genero IN ('M', 'F', 'O')) -- El g√©nero debe ser 'M', 'F' o 'O'
);
```

!!! example "Ejemplos de validaciones de datos"

    - **`CHECK`**: Permite definir una condici√≥n que los datos deben cumplir.
        ```sql
        CREATE TABLE Productos (
            id INT,
            nombre VARCHAR(50),
            precio DECIMAL(10,2),
            stock INT,
            CONSTRAINT chk_precio CHECK (precio > 0),
            CONSTRAINT chk_stock CHECK (stock >= 0)
        );
        ```

    - **`BETWEEN`**: Se puede usar dentro de un `CHECK` para validar un rango.
        ```sql
        ALTER TABLE Empleados ADD CONSTRAINT chk_edad CHECK (edad BETWEEN 18 AND 65);
        ```

    - **Conjunto de valores (`IN`)**: Tambi√©n se usa con `CHECK` para limitar los valores a una lista.
        ```sql
        ALTER TABLE Pedidos ADD CONSTRAINT chk_estado CHECK (estado IN ('pendiente', 'enviado', 'entregado'));
        -- Aunque para esto, en MySQL es m√°s eficiente y com√∫n usar ENUM.
        ```

    - **`NULL` / `NOT NULL`**: La restricci√≥n m√°s b√°sica. `NOT NULL` obliga a que la columna siempre tenga un valor.
        ```sql
        CREATE TABLE Usuarios (
            id INT,
            email VARCHAR(100) NOT NULL
        );
        ```


### Gesti√≥n de restricciones

Para a√±adir o borrar una restricci√≥n en una tabla , se utiliza el comando `ALTER TABLE` junto con la cl√°usula `ADD CONSTRAINT` y `DROP CONSTRAINT`.

La sintaxis b√°sica para a√±adir una restricci√≥n es la siguiente:

```sql
ALTER TABLE nombre_tabla
    ADD CONSTRAINT nombre_restriccion tipo_restriccion (columnas);
```

La sintaxis b√°sica para eliminar una restricci√≥n es la siguiente:

```sql
ALTER TABLE nombre_tabla
	DROP CONSTRAINT nombre_restriccion;
```

Si queremos ver las restricciones de una tabla, podemos usar el comando `SHOW CREATE TABLE`:

```sql
SHOW CREATE TABLE nombre_tabla;
```

!!! warning "Advertencia"

	Si a√±adimos una restricci√≥n tipo `CHECK` con datos existentes en la tabla, MySQL **NO validar√° los datos existentes**.<br>
	Solo se validar√°n los nuevos datos que se inserten o actualicen despu√©s de a√±adir la restricci√≥n.

	Por otro lado, si a√±adimos una restricci√≥n tipo `UNIQUE`, `NULL`, `NOT NULL`, `PRIMARY KEY` o `FOREIGN KEY` con datos existentes en la tabla, MySQL **validar√° TODOS los datos existentes**. Si alg√∫n dato no cumple con la restricci√≥n, MySQL devolver√° un error y no se a√±adir√° la restricci√≥n.


### Vistas

Una vista es una tabla virtual que se crea a partir de una consulta SQL. Las vistas permiten simplificar consultas complejas, mejorar la seguridad al restringir el acceso a ciertos datos y proporcionar una capa de abstracci√≥n sobre las tablas subyacentes.

Las vistas se crean utilizando el comando `CREATE VIEW`. La sintaxis b√°sica para crear una vista es la siguiente:

```sql
CREATE VIEW nombre_vista AS
    consulta_sql;
```

Por ejemplo, si tenemos una tabla `empleados` y queremos crear una vista que muestre solo los nombres y correos electr√≥nicos de los empleados, podemos hacerlo de la siguiente manera:

```sql
CREATE VIEW vista_empleados AS
    SELECT nombre, email
    FROM empleados;
```

Dado que no se han estudiando las consultas SQL, regresaremos a las vistas en unidades posteriores.