# **2.4. El modelo relacional**

!!! tip "Presentaci√≥n Modelo Relacional"

    üî• Fundamental ver: [Presentaci√≥n en Genially del modelo relacional](https://view.genially.com/671f4aa89a3556cea96e8ac2/learning-experience-didactic-unit-modelo-relacional)

En la [unidad anterior](../02/2.1-ModeloER.md) estudiamos que un **modelo l√≥gico** representa de forma conceptual la estructura de una base de datos, pero dependiendo del SGBD a utilizar.

<figure markdown="span">
  <img src="images/03modelo-logico.png" width="100%">
  <figcaption>Modelo l√≥gico</figcaption>
</figure>


Si nuestra elecci√≥n es un SGBD relacional, el modelo por excelencia es el **modelo relacional**. Creado por _Codd_ a finales de los a√±os 60, aunque los primeros SGBD relacionales no aparecieron hasta los 80. Una base de datos modelada mediante el modelo relacional se conoce como una base de datos relacional.

Supuso una revoluci√≥n en el dise√±o l√≥gico de las base de datos, dando lugar a la segunda generaci√≥n de SGBD.

Es el modelo l√≥gico m√°s extendido, y _por ende_, el mercado de SGBD est√° copado de soluciones relacionales como _Oracle_, _PostgreSQL_, _MySQL_, _SQL Server_, etc...

Los objetivos del modelo relacional son:

- Independencia f√≠sica
    - La forma de almacenar los datos no debe influir en su manipulaci√≥n l√≥gica
- Independencia l√≥gica
    - Las aplicaciones que usan el SGBD no deben sufrir una modificaci√≥n cuando se modifique una base de datos.
- Flexibilidad
    - Diferentes vistas para diferentes usuarios
- Uniformidad
- Sencillez


## 2.4.1 Elementos

El elemento principal es la **relaci√≥n**, que consiste en una tabla que contiene filas y columnas. Una base de datos relacional consiste en un conjunto de tablas relacionadas donde cada tabla tiene un nombre √∫nico.

Las relaciones se conocen como tablas relacionales o m√°s com√∫nmente como **tablas**.

Cada **columna** (tambi√©n llamado **campo** o atributo de la relaci√≥n) almacena informaci√≥n sobre una propiedad determinada de la tabla, como puede ser el nombre, DNI, apellidos o la edad.

Cada **fila** posee una ocurrencia o ejemplar de la instancia o relaci√≥n representada por la tabla (a las filas se las llama tambi√©n **tuplas** o **registros**).

<figure markdown="span">
  <img src="images/03elementos-tabla.png" width="100%">
  <figcaption>Elementos de una tabla</figcaption>
</figure>


As√≠ pues, un ejemplo de una relaci√≥n `CLIENTE` de grado 5 (`dni`, `nombre`, `direccion`, `fecha` y `genero`) con 3 tuplas ser√≠a:

| dni | nombre | direcci√≥n | fecha | genero |
| --- | --- | --- | --- | --- |
| 12345678A | Pedro Casas | Avenida de la libertad, 23 | 21/03/24 | M |
| 48123456B | Mireia Vidal | Porta de la Morera, 6 | 22/03/24 | F |
| 34123456C | Laura Meca | Pla√ßa de Baix, s/n | 23/03/24 | F |

Como podemos observar, en la cabecera est√°n los nombres de las columnas, y cada fila supone una nueva ocurrencia. Podemos referirnos al campo de una tabla mediante la notaci√≥n **`TABLA.campo`**, por ejemplo, `CLIENTE.nombre` referencia el campo `nombre` de la tabla `CLIENTE`.

En una misma tabla, no podemos repetir el nombre de las columnas, aunque s√≠ que lo podemos repetir en tablas diferentes. Por ejemplo, `CLIENTE.dni` y `PROVEEDOR.dni` ser√≠an campos de tablas diferentes con el mismo nombre.

Una restricci√≥n del modelo relacional es que dentro de una tabla no puede haber dos tuplas iguales, ya que implicar√≠a el mismo dato dos veces. Adem√°s, todas las tuplas deben tener el mismo n√∫mero de campos, aunque alguno est√© vac√≠o (se permiten campos con valores nulos).

!!! sa "El orden no importa"

    El orden de las tuplas no importa, ni tampoco el orden de los atributos.

    Dicho esto, esta ser√≠a otra representaci√≥n de la misma tabla:

    | dni | direcci√≥n | genero | fecha | nombre |
    | --- | --- | --- | --- | --- |
    | 34123456C | Pla√ßa de Baix, s/n | F | 23/03/24 | Laura Meca |
    | 48123456B | Porta de la Morera, 6 | F | 22/03/24 | Mireia Vidal |
    | 12345678A | Avenida de la libertad, 23 | M | 21/03/24 | Pedro Casas |


### Dominio

El dominio de un atributo indica el tipo de valores para un determinado campo. Dicho de otro modo, cada atributo s√≥lo puede tomar un valor en el dominio en el que est√° inscrito.

Si nos basamos en el ejemplo anterior, tendr√≠amos que los dominios ser√≠an:

- `dni`: 8 d√≠gitos y una letra.
- `nombre`: cadena de hasta 32 caracteres.
- `direcci√≥n`: cadena de hasta 64 caracteres.
- `fecha`: fecha compuesta de `dd/mm/yy`.
- `genero`: caracteres `M`, `F` o `?`

Como cada atributo s√≥lo puede tomar un valor para una misma tupla (los valores de los campos son at√≥micos), no podr√≠amos poner dos DNIs o dos fechas a un mismo cliente.

A muy alto nivel, los tipos de datos b√°sicos para los dominios son:

- Texto: cadena de caracteres, letras, s√≠mbolos o n√∫meros con los que no se realizan operaciones (por ejemplo, un c√≥digo postal).
- Num√©rico: n√∫meros sobre los cuales se pueden realizar operaciones matem√°ticas.
- Fecha/hora: fechas, horas, o ambas.
- Booleano (V/F - S√≠/No): datos con dos posibles valores.
- Autonum√©rico: secuencia (1,2,3,...) que el SGBD incrementa de forma autom√°tica cuando se a√±ade un nuevo registro.

Tipos de dominio

Cuando estudiemos el modelo f√≠sico haremos m√°s hincapi√© en todos los tipos de dominio existente. De momento, lo m√°s importante es tener claro que todos los valores de un determinado campo en una tabla comparten el mismo dominio.

### Claves

Cada tabla tiene una columna (o en algunos casos un conjunto de columnas) que sirven como **clave primaria** (**PK** / _primary key_). Su prop√≥sito es distinguir a una tupla de otra dentro de la tabla.

Cada tabla debe tener una clave primaria, la cual es una columna (o conjunto de columnas) cuyo valor es √∫nico para cada fila.

Volvamos al ejemplo anterior sobre la tabla `CLIENTE`:

| dni | nombre | direcci√≥n | fecha | genero |
| --- | --- | --- | --- | --- |
| 12345678A | Pedro Casas | Avenida de la libertad, 23 | 21/03/24 | M |
| 48123456B | Mireia Vidal | Porta de la Morera, 6 | 22/03/24 | F |
| 34123456C | Laura Meca | Pla√ßa de Baix, s/n | 23/03/24 | F |

El campo `dni` funciona como clave primaria de la tabla, ya que no hay dos clientes con el mismo DNI. Pero ¬øy el campo `nombre`? Aunque en la tabla no tengamos ahora mismo dos clientes con el mismo nombre, conceptualmente sabemos que se puede dar el caso, y por lo tanto, no ser√≠a una elecci√≥n correcta, ya que el nombre de un cliente no lo identifica de forma univoca.

#### Clave subrogada

Cuando en una tabla no tengamos una columna que identifique claramente a una tabla, podemos crear una nueva columna num√©rica, normalmente denominada `id`, que tomas valores secuenciales y autoincrementables, de manera que act√∫a como una clave sustituta independiente de los valores de negocio, que realmente no tiene un significado por s√≠ misma.

Si a√±adimos una clave subrogada a la tabla `CLIENTE` tendr√≠amos:

| id | dni | nombre | direcci√≥n | fecha | genero |
| --- | --- | --- | --- | --- | --- |
| 1 | 12345678A | Pedro Casas | Avenida de la libertad, 23 | 21/03/24 | M |
| 2 | 48123456B | Mireia Vidal | Porta de la Morera, 6 | 22/03/24 | F |
| 3 | 34123456C | Laura Meca | Pla√ßa de Baix, s/n | 23/03/24 | F |

#### Claves candidatas

Si una tabla tiene m√°s de un campo (o un conjunto de ellos) que pueden identificar un√≠vocamente a cada tupla de la tabla, se dice que todas las claves posibles son **claves candidatas**.

De entre las claves candidatas, elegiremos una como la clave primaria y el resto ser√°n **claves alternativas**. As√≠ pues, una clave alternativa es una clave candidata que no es primaria.

Por ejemplo, si pensamos en la tabla `ESTUDIANTE` podemos definir los siguientes campos: `nif`, `codigo`, `nombre`, `fMatricula`, `direccion`. Las claves candidatas ser√≠an `ESTUDIANTE.codigo` y `ESTUDIANTE.nif`, ya que permiten identificar de forma un√≠voca a cada estudiante. Si nos decantamos por `ESTUDIANTE.codigo` como su clave primaria, entonces `ESTUDIANTE.nif` ser√≠a una clave alternativa.

| nif | codigo | nombre | fMatricula | direccion |
| --- | --- | --- | --- | --- |
| 12345678A | 1 | Pedro Casas | 1/9/24 | Avenida de la libertad, 23 |
| 48123456B | 2 | Mireia Vidal | 1/9/24 | Porta de la Morera, 6 |
| 34123456C | 3 | Laura Meca | 1/9/24 | Pla√ßa de Baix, s/n |

#### Claves ajenas

Finalmente, tenemos las **claves ajenas** (**FK** / _foreign key_), los cuales son campos cuyos valores referencian a valores de otra tabla.

Dentro del modelo relacional, el hecho de relacionar los datos de una tabla con otra es crucial, y se realiza mediante las claves ajenas. As√≠ pues, la clave ajena de una tabla referencia, normalmente, al valor de la clave primaria de otra tabla. Por ello, los dominios de la clave ajena y de la clave primaria referenciada deben ser iguales (un campo num√©rico no puede referenciar a un campo de texto).

Comencemos con el mismo ejemplo que vimos con las [relaciones 1:N](../02/2.1-ModeloER.html#relacion-1n) del modelo conceptual, donde ten√≠amos que todo producto tiene una categor√≠a, pero de una categor√≠a, tenemos muchos productos, el cual representamos as√≠:

Si lo representamos mediante tablas, podr√≠amos tener la siguiente estructura:


<div class="grid cards" markdown>

  - `CATEGORIA`
    
    | codigo | nombre |
    | --- | --- |
    | 1 | Consola |
    | 2 | TIC |
    | 3 | Cocina |
    | 4 | Bricolaje |

  - `PRODUCTO`
    
    | codigo | nombre | codCategoria`*` |
    | --- | --- | --- |
    | 1 | PS5 | 1 |
    | 2 | Nevera | 3 |
    | 3 | Teclado | 2 |
    | 4 | XBOX | 1 |
    | 5 | Rat√≥n | 2 |
    | 6 | Volante | `NULL` |

  - Representaci√≥n de las ocurrencias
    
    ![](../02/images/02ocurrencias1n.png "Ocurrencias 1:N"){ align="center"}  

  - Representaci√≥n relacional
    
    ---
    
    ![](images/03producto-categoria.png "Representaci√≥n Producto-Categor√≠a")


</div>


Puedes observar como hemos subrayado las claves primaria de cada tabla. ¬øQu√© atributo tiene la funci√≥n de clave ajena? En este ejemplo, la columna `PRODUCTO.codCategoria` es una clave ajena que apunta a `CATEGORIA.codigo` (f√≠jate que en este caso, al atributo que es clave ajena le hemos puesto un asterisco `*` tras su nombre). Si revisamos los valores, podemos comprobar como podemos tener valores repetidos y valores nulos, facilitando que de una categor√≠a tengamos varios productos (categor√≠as de los productos `1` y `4`), que de una categor√≠a no tengamos productos (la categor√≠a `4` no est√° asociada a ning√∫n producto) y, aunque el modelo conceptual no representaba dicha cardinalidad, que tengamos productos sin categor√≠a (como el producto `6`).

Cuando tenemos dos tablas relacionadas mediante una clave ajena, mediante operaciones relacionales que veremos en la [Unidad 6](https://aitor-medrano.github.io/bd/06sql.html), podremos crear una nueva relaci√≥n con el resultado de unir una clave ajena con los datos a los que referencia.

As√≠ pues, al unir ambas tablas, obtendr√≠amos como resultado:

| PRODUCTO.codigo | PRODUCTO.nombre | PRODUCTO.codCategoria | CATEGORIA.nombre |
| --- | --- | --- | --- |
| 1 | PS5 | 1 | Consola |
| 2 | Nevera | 3 | Cocina |
| 3 | Teclado | 2 | TIC |
| 4 | XBOX | 1 | Consola |
| 5 | Rat√≥n | 2 | TIC |
| 6 | Volante | `NULL` | `NULL` |

---

Veamos otro ejemplo, donde tenemos dos tablas, una para estudiantes (igual que el ejemplo de las claves candidatas) y otra para almacenar qu√© cursos realizan los estudiantes, similares a las siguientes:

- `ESTUDIANTE`
    
    | nif | codigo | nombre | fMatricula | direccion |
    | --- | --- | --- | --- | --- |
    | 12345678A | 1 | Pedro Casas | 1/9/24 | Avenida de la libertad, 23 |
    | 48123456B | 2 | Mireia Vidal | 1/9/24 | Porta de la Morera, 6 |
    | 34123456C | 3 | Laura Meca | 1/9/24 | Pla√ßa de Baix, s/n |
    
- `CURSAR`
    
    | nifEstudiante`*` | asignatura | anyo | repetidor |
    | --- | --- | --- | --- |
    | 12345678A | 1 | 2024 | true |
    | 48123456B | 1 | 2024 | false |
    | 12345678A | 2 | 2023 | false |
    

El campo `CURSAR.nifEstudiante` es una clave ajena de la relaci√≥n `CURSAR` y enlaza con la relaci√≥n `ESTUDIANTE` con el campo `ESTUDIANTE.nif`.

Visualmente, lo podemos representar mediante el siguiente gr√°fico:

<figure markdown="span">
  <img src="images/03estudiante-cursar.png" width="60%">
  <figcaption>Clave ajena entre ESTUDIANTE y CURSAR</figcaption>
</figure>

Conviene aclarar que un campo puede ser clave primaria y clave ajena a la vez. Adem√°s, una tabla puede tener m√°s de una clave ajena o no tener ninguna. Adem√°s, en el caso de las relaciones reflexivas, la clave ajena de la relaci√≥n enlazar√° con la clave primaria de s√≠ misma.

#### Borrado y actualizaci√≥n

Cuanto trabajamos con varias tablas relacionadas mediante claves ajenas y claves primarias, debemos definir las reglas y modificar la clave primaria a la que referencian.

Al actualizar/borrar un registro que contiene una clave ajena, se puede:

- **Rechazar**: no se permite el borrado/modificaci√≥n
- **Propagar**: se borra/modifica el registro, y las tuplas que lo referencian
- **Anular**: se borra/modifica el registro y las tuplas que lo referencian ponen a nulo la clave ajena.

 
!!! question "Autoevaluaci√≥n"

    Si volvemos a la relaci√≥n entre `ESTUDIANTE` y `CURSAR`, ¬øqu√© sucede cuando eliminamos el estudiante `12345678A`?

    - `ESTUDIANTE`
        
        | nif | codigo | nombre | fMatricula | direccion |
        | --- | --- | --- | --- | --- |
        | 12345678A | 1 | Pedro Casas | 1/9/24 | Avenida de la libertad, 23 |
        | 48123456B | 2 | Mireia Vidal | 1/9/24 | Porta de la Morera, 6 |
        
    - `CURSAR`
        
        | nifEstudiante`*` | asignatura | anyo | repetidor |
        | --- | --- | --- | --- |
        | 12345678A | 1 | 2024 | `true` |
        | 48123456B | 1 | 2024 | `false` |
        | 12345678A | 2 | 2023 | `false` |
    
 
 Profundizaremos en las operaciones entre claves ajenas y primarias cuando trabajemos las operaciones DML sobre el modelo f√≠sico en la _Unidad 3.- Lenguaje de definici√≥n de datos (DDL)_.

## 2.4.2Restricciones sem√°nticas

A la hora de definir las propiedades de una tabla y sus columnas podemos emplear las siguientes restricciones:

- **clave primaria**: los atributos marcados como clave primaria no puedan repetir valores.
- **unicidad**: impide que los valores de los atributos marcados de esa forma puedan repetirse, consider√°ndose un√≠vocos. A nivel visual se marcan con `UK`. Vamos a considerar que un atributo `UK` no permite valores repetidos pero s√≠ nulos (dependiendo del SGBD, en algunos casos se permiten y en otros no).
- **obligatoriedad** (`VNN`): proh√≠be que el atributo marcado de esta forma no tenga ning√∫n valor (valor no nulo).
- **regla de validaci√≥n**: condici√≥n que debe de cumplir un dato concreto para que sea actualizado.

Adem√°s, podemos definir diferentes restricciones:

- a **nivel de fila**, por ejemplo, de relaci√≥n entre columnas, del tipo la fecha de devoluci√≥n debe ser posterior a la fecha de pr√©stamo
- a **nivel de conjunto de filas**, por ejemplo, un cliente no puede hacer m√°s de 20 pedidos en un d√≠a
- a **nivel de negocio**, del tipo, al insertar un pedido, se debe comprobar si la direcci√≥n de env√≠o es la misma que la direcci√≥n del cliente, y en caso de no serlo, a√±adir una nueva direcci√≥n al cliente.

### Nulos

Los valores nulos (`NULL`) indican contenidos de atributos que no tienen ning√∫n valor, bien porque la informaci√≥n es desconocida o no aplicable. Es decir, m√°s que un valor, es la ausencia de informaci√≥n. Algunos SGBD muestran la palabra clave `NULL`, mientras que otros muestran el campo en blanco.

Por ejemplo, si en la tabla `ESTUDIANTE` tenemos un registro con la direcci√≥n nula, est√° indicando que desconocemos la direcci√≥n de `Mireia Vidal`, no que no tenga direcci√≥n.

| nif | codigo | nombre | fMatricula | direccion |
| --- | --- | --- | --- | --- |
| 12345678A | 1 | Pedro Casas | 1/9/24 | Avenida de la libertad, 23 |
| 48123456B | 2 | Mireia Vidal | 1/9/24 | `NULL` |
| 34123456C | 3 | Laura Meca | 1/9/24 | Pla√ßa de Baix, s/n |

Si el campo es una clave ajena, indica que el registro actual no est√° relacionado con ninguno.

Las bases de datos relacionales admiten utilizar ese valor en todo tipo de operaciones.

En cuanto a los campos booleano (V/F), define un tercer valor en la l√≥gica, ya que adem√°s del valor verdadero o falso, existe el valor para los nulos.

### Integridad de entidad

La integridad de entidad define que todas las claves primarias deben tener valor, y, por lo tanto, no admiten valores nulos.

Si volvemos a la tabla `ESTUDIANTE`, no podemos tener ning√∫n estudiante con el NIF vac√≠o.

Al definir un campo como `PK` ya estamos declarando que dicho campo no admite valores nulos (ni repetidos por el propio concepto de clave primaria).

### Integridad referencial

Si una relaci√≥n R1 posee una clave ajena que la enlaza con la relaci√≥n R2, entonces diremos que cumple la restricci√≥n de **integridad referencial** si todo valor de dicha clave ajena de R1 cumple una de las dos condiciones:

1. coincide con alg√∫n valor de la clave primaria en la relaci√≥n R2
2. toma el valor nulo (`NULL`)

Es decir, proh√≠be colocar valores en una clave ajena que no est√©n reflejados en la clave primaria de la tabla que relaciona.

Veamos un ejemplo que no cumple con la integridad referencial. Tengamos los siguientes datos, sabiendo que `CURSAR.nifEstudiante` es una clave ajena que apunta a `ESTUDIANTE.nif`:

- `ESTUDIANTE`
    
    | nif | codigo | nombre | fMatricula | direccion |
    | --- | --- | --- | --- | --- |
    | 12345678A | 1 | Pedro Casas | 1/9/24 | Avenida de la libertad, 23 |
    | 48123456B | 2 | Mireia Vidal | 1/9/24 | Porta de la Morera, 6 |
    | 34123456C | 3 | Laura Meca | 1/9/24 | Pla√ßa de Baix, s/n |
    
- `CURSAR`
    
    | nifEstudiante`*` | asignatura | anyo | repetidor |
    | --- | --- | --- | --- |
    | 12345678A | 1 | 2024 | `true` |
    |  | 1 | 2024 | `false` |
    | 66666666Z | 2 | 2023 | `false` |
    

El primer fallo que encontramos es que el campo `CURSAR.nifEstudiante` contiene nulos. Aunque las claves ajenas permiten valores nulos, al tratarse tambi√©n de una clave primaria, estar√≠a incumpliendo la integridad de entidad.

El segundo error es que el valor `66666666Z` referencia a un estudiante invalido, y este valor s√≠ que viola la integridad referencial, ya que dicho valor no existe en `ESTUDIANTE.nif`.

## 2.4.3 Notaci√≥n

Para representar una tabla en el modelo relaci√≥n usaremos una notaci√≥n textual que facilita su comprensi√≥n y posterior transformaci√≥n al modelo f√≠sico. A esta representaci√≥n se le conoce como **esquema relacional** (o esquema l√≥gico/can√≥nico).

Pondremos el nombre de la tabla en may√∫sculas, y a continuaci√≥n, entre par√©ntesis, enumeraremos los campos mediante su nombre en min√∫sculas (y opcionalmente su dominio). Como convenci√≥n, el primer atributo ser√° aquel que hace la funci√≥n de clave primaria, el cual adem√°s subrayaremos para facilitar la legibilidad, y a aquellos campos que sean claves ajenas les a√±adiremos un asterisco (`*`) para indicar su condici√≥n.

Tras el listado de campos, enumeraremos las restricciones, con el siguiente orden:

1. la clave primaria (`PK`), con el atributo o conjunto de atributos que identifican un√≠vocamente a una tupla.
2. las claves ajenas (`FK`) (si las hubiera), indicando el nombre de la columna, una flecha, y la relaci√≥n a la que referencia.
3. el resto de restricciones (`UK`, `VNN`, comprobaciones, etc...) (si las hubiera)

M√°s propiedades

Un campo puede tener opcionalmente las siguientes propiedades:

- Descripci√≥n: texto breve que aporta informaci√≥n sobre el contenido o la finalidad del campo.
- Tama√±o: tama√±o m√°ximo permitido.
- Rango de valores posibles, a modo de enumeraci√≥n.
- Requerido o `NOT NULL`: no permite valores nulos.
- Predeterminado (`DEFAULT`): valor por defecto para cuando no se inserta ning√∫n valor.

Por ejemplo, un esquema l√≥gico en modelo relacional que relaciona un libro con un autor, y un autor con muchos libros (relaci√≥n 1:N) podr√≠a ser el siguiente:

`**AUTOR** (codigo: autonum√©rico, nombre: texto, fnac: fecha, nacionalidad: texto)`<br>
`¬∑ PK: (codigo)`

`**LIBRO** (isbn: texto, titulo: texto, descripcion: texto, autor*: num√©rico, editorial: texto, pvp: real)`<br>
`¬∑ PK: (isbn)`<br>
`¬∑ FK: (autor) ‚Üí AUTOR`<br>

Por legibilidad, vamos a omitir los dominios y representar las tablas √∫nicamente con el nombre de los campos, y posteriormente, en el diccionario de datos, definiremos sus tipos. De este modo, quedar√≠a as√≠:

`**AUTOR** (codigo, nombre, fnac, pais)`
`¬∑ PK: (codigo)`

`**LIBRO** (isbn, titulo, autor*, editorial, pvp)`
`¬∑ PK: (isbn)`   
`¬∑ FK: (autor) ‚Üí AUTOR`

!!! fact "DBML - Database Markup Language"

    Tenemos que el autor se identifica por un c√≥digo, el cual es su clave primaria. En cambio, los libros se identifican por su ISBN, y tienen un atributo `autor` que referencia a la clave primaria de `AUTOR` (y por tanto, deben tener el mismo dominio). De esta relaci√≥n, deducimos que el nombre del atributo de la clave ajena no tiene por qu√© coincidir con el nombre de la clave primaria, pero s√≠ su dominio.

    Si analizamos las cardinalidades de las tablas, tenemos:

    - `Card(LIBRO, ESCRIBIR) = (0, 1)`: Todo libro tiene un atributo autor, y s√≥lo uno, el cual puede estar rellenado o no.
    - `Card(AUTOR, ESCRIBIR) = (0, N)`: Si un libro tiene un atributo autor, y el mismo autor puede aparecer en m√°s de un libro, entonces un autor puede escribir muchos libros (o ninguno, si no aparece en ninguna ocurrencia de `LIBRO`).

    En la pr√≥xima unidad estudiaremos el proceso de transformaci√≥n de un modelo conceptual a uno relacional, y en concreto, c√≥mo se gestionan las claves ajenas para cumplir las cardinalidades y restricciones de las relaciones.
    
    
    La notaci√≥n que vamos a emplear en clase es sencilla y cumple su prop√≥sito.

    Dicho esto, desde principio de 2020, gracias a la empresa https://dbdiagram.io/, se est√° popularizando [DBML](https://dbml.dbdiagram.io/home) como un lenguaje de marcado para representar bases de datos.

    Si quieres profundizar en su uso, es recomendable consultar su [sintaxis](https://dbml.dbdiagram.io/docs) o puedes probar a generar diagramas en [https://dbdiagram.io/](https://dbdiagram.io/).

    En nuestro caso, por ejemplo, podemos representa las entidades `AUTOR` y `LIBRO` del siguiente modo:

    ```
    Table AUTOR {
        codigo entero [primary key]
        nombre cadena
        fnac fecha
        pais cadena
    }

    Table LIBRO {
        isbn cadena [primary key]
        titulo cadena
        autor entero [ref: > AUTOR.codigo]
        editorial cadena
        pvp real
    }
    ```

    Obteniendo como resultado el diagrama:
    
    <figure markdown="span">
        <img src="images/03autor-libro.png" width="60%">
        <figcaption>Diagrama AUTOR-LIBRO</figcaption>
    </figure>
 
 
 
 Vamos a crear datos ficticios y comprobaremos si el modelo cumple la relaci√≥n de uno a muchos:

- `AUTOR`
    
    | codigo | nombre | fnac | pais |
    | --- | --- | --- | --- |
    | 1 | Brandon Sanderson | 19/12/75 | USA |
    | 2 | Juan G√≥mez Jurado | 16/12/77 | Espa√±a |
    | 3 | J√∂el Dicker | 16/06/85 | Suiza |
    
- `LIBRO`
    
    | isbn | titulo | autor`*` | editorial | pvp |
    | --- | --- | --- | --- | --- |
    | 9788420476841 | Un animal salvaje | 3 | Alfaguara | 23,90 |
    | 9788420414065 | La verdad sobre el caso Harry Quebert | 3 | Alfaguara | 23,90 |
    | 9788491221722 | Lazarillo de Tormes | `NULL` | Santillana | 14,20 |
    | 9788419260444 | Nacidos de la bruma | 1 | Nova | 24,90 |
    

As√≠ pues, comprobamos que tenemos un autor (el `3` con dos libros), e incluso un libro sin autor, confirmando la relaci√≥n 1:N conforme quer√≠amos dise√±ar.

**Cardinalidad de las relaciones**

Con lo que sabemos hasta ahora, piensa:

- ¬øC√≥mo evitamos que la cardinalidad m√≠nima sea 0 entre LIBRO y AUTOR, es decir, que `Card(LIBRO, ESCRIBIR) = (1,1)`, de manera que cada libro lo escriba siempre un autor, no permitiendo valores nulos en la clave ajena?
- ¬øC√≥mo cambiamos la relaci√≥n de 1:N a una relaci√≥n 1:1, para que cada autor solo pudiera escribir un libro?

### Representaci√≥n gr√°fica

Aunque ya hemos visto que podemos emplear [DBDiagrams](https://dbdiagram.io/) para generar un diagrama a partir del esquema l√≥gico mediante [DBML](https://dbml.dbdiagram.io/docs), tambi√©n podemos emplear diversas herramientas existentes en el mercado, como [ERDPlus](https://erdplus.com/) o [MySQLWorbench](https://www.mysql.com/products/workbench/) (m√°s cercano al modelo f√≠sico), que permiten dibujar los elementos.

En nuestro caso, nos vamos a centrar en DBDiagrams, principalmente por ser una herramienta online y que actualmente el lenguaje [DBML (Database Markup Language)](https://dbml.dbdiagram.io/home/) se est√° instaurando como el lenguaje de referencia para esta funci√≥n.
 
 
### Diccionario de datos

El diccionario de datos de un modelo relacional es un repositorio central que almacena metadatos sobre los elementos de una base de datos.

En un sistema de bases de datos relacional, el diccionario de datos incluye detalles sobre las estructuras de las tablas, las relaciones entre las tablas, las columnas, los √≠ndices, las restricciones, los procedimientos almacenados y otros objetos de la base de datos. Es esencialmente un _cat√°logo_ que describe la estructura l√≥gica y la organizaci√≥n de la base de datos.

Las funciones del diccionario de datos son:

- **Documentaci√≥n**: Sirve como referencia para desarrolladores y administradores de bases de datos, ayud√°ndoles a entender la estructura y organizaci√≥n de la base de datos.
    
- **Control de integridad**: Ayuda a asegurar que las definiciones de las tablas y relaciones se mantengan coherentes y conformes a las reglas establecidas.
    

#### Componentes

1. **Tablas y columnas**: Describe las tablas en la base de datos, los nombres de las columnas, tipos de datos (los diferentes [tipos de datos](#todo) los estudiaremos en detalle en la _unidad 3_, tama√±os y si permiten valores nulos.
    
2. **Relaciones y claves**: Define las relaciones entre tablas y especifica las claves primarias y ajenas.
    
3. **Restricciones**: Incluye detalles sobre restricciones como `UNIQUE`, `CHECK`, `NOT NULL`, y `DEFAULT`.
    

Si nos centramos en los modelos f√≠sicos, podr√≠amos incluir otros componentes como √≠ndices, vistas, procedimientos almacenados y funciones o _triggers_, as√≠ como usuarios y permisos.

#### Ejemplo

Para este ejemplo, nos vamos a basar en el mismo ejemplo que hemos utilizado en el apartado de [Notaci√≥n](#notaci√≥n), donde un `AUTOR` escribe muchos `LIBRO`, pero un `LIBRO` s√≥lo lo escribe un `AUTOR`.

Para documentar el diccionario de datos, se utiliza una estructura de tabla con el nombre de la columna, el tipo de datos y una descripci√≥n del campo:

- Tabla `AUTOR`
    
    | **Columna** | **Tipo de Datos** | **Descripci√≥n** |
    | --- | --- | --- |
    | `codigo` | `INT` | Clave primaria. Identificador √∫nico del autor. |
    | `nombre` | `VARCHAR(64)` | Nombre del autor. |
    | `fnac` | `DATE` | Fecha de nacimiento del autor. |
    | `pais` | `VARCHAR(32)` | Pa√≠s de nacimiento del autor. |
    
- Tabla `LIBRO`
    
    | **Columna** | **Tipo de Datos** | **Descripci√≥n** |
    | --- | --- | --- |
    | `isbn` | `INT` | Clave primaria. Identificador √∫nico del libro. |
    | `titulo` | `VARCHAR(64)` | T√≠tulo del libro. |
    | `autor` | `INT` | Clave for√°nea que referencia a `AUTOR.codigo`. Indica el autor del libro. |
    | `editorial` | `VARCHAR(32)` | Editorial que publica el libro. |
    | `pvp` | `DECIMAL(10,2)` | Precio de venta al p√∫blico del libro. |
    

A continuaci√≥n, indicamos las relaciones y restricciones

- **Clave primaria en `AUTOR`**: `codigo`
- **Clave primaria en `LIBRO`**: `isbn`
- **Clave ajena en `LIBRO`**: `autor` referencia a `codigo` en la tabla `AUTOR`, indicando la relaci√≥n entre un libro y su autor.
    - Restricci√≥n de borrado: rechazar.
    - Restricci√≥n de modificaci√≥n: propagar.
 
---

## 2.4.4 Normalizaci√≥n

Un principio del dise√±o relacional es que "_hechos distintos se deben almacenar en objetos distintos_".

Para conseguir este objetivo, la **normalizaci√≥n** es una t√©cnica dentro del dise√±o de bases de datos relacionales que consiste en la separaci√≥n de atributos en tablas lo m√°s simples posibles para **suprimir dependencias err√≥neas entre atributos, reducir la redundancia as√≠ como optimizar los procesos de inserci√≥n, modificaci√≥n y borrado en la bases de datos**, evitando las anomal√≠as previamente comentadas, lo que maximiza la integridad de los datos y su consistencia.

Podemos simplificar el objetivo de la normalizaci√≥n en **maximizar la integridad de los datos, reduciendo su redundancia**.

Para conseguirlo, se basa en el an√°lisis de dependencias entre atributos mediante un proceso que consiste en identificar y aplicar una serie de reglas a las relaciones obtenidas del esquema relacional.
 
 
!!! abstract "Supuesto Comerciales"

    Supongamos los siguientes datos sobre ventas que realizan una serie de comerciales de los cuales tenemos su c√≥digo y nombre, su estado laboral (con un c√≥digo y una descripci√≥n), la ciudad y la provincia donde realizan las ventas, as√≠ como las poblaciones de dichas ciudades y provincias.

    | comercialID | comercialNom | estadoID | estadoDesc | ciudad | provincia | ciudadPob | provinciaPob | ventas |
    | --- | --- | --- | --- | --- | --- | --- | --- | --- |
    | C1 | Carlos Suarez | JC | Jornada Completa | Elche | Alicante | 230.000 | 1.800.000 | 33 |
    | C1 | Carlos Suarez | JC | Jornada Completa | Denia | Alicante | 42.000 | 1.800.000 | 22 |
    | C2 | Manoli Campos | JC | Jornada Completa | Elche | Alicante | 230.000 | 1.800.000 | 55 |
    | C2 | Manoli Campos | JC | Jornada Completa | Aspe | Alicante | 22.000 | 1.800.000 | 44 |
    | C3 | Carlos Suarez | JPM | Jornada Partida Ma√±anas | Cartagena | Murcia | 218.000 | 1.520.000 | 17 |
    | C4 | Sonia S√°nchez | JPT | Jornada Partida Tardes | Gand√≠a | Valencia | 73.000 | 2.550.000 | 27 |
    | C5 | Marina Vidal | JC | Jornada Completa | Valencia | Valencia | 807.000 | 1.800.000 | 37 |
    | C6 | Michael Johnson | JC | Jornada Completa | Valencia | California | 63.000 | 38.940.000 | 47 |

    Claramente, tenemos datos redundantes. Si reorganizamos los datos de otra manera podr√≠amos evitar dependencias.

### Anomal√≠as

Una **anomal√≠a** se refiere a una inconsistencia o problema que puede surgir en una base de datos, especialmente cuando no est√° normalizada. Estas anomal√≠as pueden manifestarse de diversas maneras, afectando la integridad y consistencia de la informaci√≥n almacenada.

Los tipos de anomal√≠as en bases de datos son:

- **anomal√≠as de actualizaci√≥n**: ocurren cuando se intenta actualizar un registro en m√∫ltiples ubicaciones y no todas las copias se actualizan correctamente, generando discrepancias en los datos.
- **anomal√≠as de inserci√≥n**: surgen cuando no se puede insertar un nuevo registro en una tabla sin introducir datos redundantes o violar ciertas restricciones. Por ejemplo, si tenemos una tabla que almacena informaci√≥n de estudiantes y cursos, si no hay una clave principal que identifique de forma √∫nica cada registro, se podr√≠an generar anomal√≠as al intentar insertar nueva informaci√≥n.
- **anomal√≠as de eliminaci√≥n**: se producen cuando se elimina informaci√≥n importante al intentar eliminar un registro espec√≠fico, lo que puede llevar a la p√©rdida de datos. Siguiendo con el ejemplo anterior, si se elimina un registro de estudiante y este registro tambi√©n contiene informaci√≥n sobre un curso, podr√≠a perderse la informaci√≥n del curso si no se toman precauciones.

Para *solucionar* las anomal√≠as, debemos **normalizar las tablas**.

### Dependencias funcionales

Antes de entrar a conocer los pasos de la normalizaci√≥n, previamente tenemos que definir una serie de conceptos:

- **Dependencia funcional** (DF): es la relaci√≥n sem√°ntica existente entre atributos de una misma tabla. Decimos que **A ‚Üí B**, es decir, que **B depende funcionalmente de A** (o A determina a B), si y solo si para cada valor de A s√≥lo puede existir un B.
    
    El sentido de la relaci√≥n no es bidireccional. Que para una valor de A s√≥lo exista un B, no significa que dado B, siempre obtengamos A. Por ejemplo, la dependencia `dni ‚Üí nombre, apellidos` es correcta, ya que tanto el nombre de una persona como sus apellidos dependen funcionalmente de su DNI, pero no al rev√©s. ¬øDado un nombre de una persona, podemos saber su DNI?


!!! abstract "DF - Supuesto Comerciales"

    > El primer paso es para cada columna, identificar las dependencias que hay entre los atributos.

    Por ejemplo, cogemos el nombre del comercial, y detectamos que dependen funcionalmente del identificador del comercial, por lo tanto: `comercialID ‚Üí comercialNom`. Pero si nos fijamos bien en los nombres de los comerciales, no podemos decir lo mismo en el sentido contrario, ya que tenemos un nombre repetido en diferentes c√≥digos de comercial (¬°qu√© casualidad!), con lo que no es correcto decir `comercialNom ‚Üí comercialID`.

    Si hacemos lo mismo con el identificador del estado del comercial, deducimos que depende tambi√©n del identificador, obteniendo `comercialID ‚Üí estadoID`.

    Y lo mismo con la descripci√≥n del estado. En este caso, se cumplen que tanto el identificador del comercial como el identificador del estado permiten obtener la descripci√≥n del estado, obteniendo `comercialID ‚Üí estadoDesc` y `estadoID ‚Üí estadoDesc`.

    Si continuamos con todos los atributos y agrupamos las dependencias funcionales tenemos:

    - `comercialID ‚Üí comercialNom, estadoID, estadoDesc`
    - `estadoID ‚Üí estadoDesc`
    - `estadoDesc ‚Üí estadoID`
    - `provincia ‚Üí provinciaPob`
    - `ciudad, provincia ‚Üí ciudadPob`, por ejemplo, tenemos dos ciudades `Valencia` en provincias diferentes
    - `comercialID , ciudad, provincia ‚Üí ventas`

    Tal como hemos comentado previamente, cuando agrupamos los atributos, la dependencia `comercialID ‚Üí comercialNom, estadoID, estadoDesc` significa que tanto el nombre del comercial, como el c√≥digo de su estado y el estado dependen del identificador del comercial.

- **Dependencia funcional completa** (DFC): cuando tenemos que _A1, A2, ...AN ‚Üí B_ (B tiene una dependencia funcional del conjunto A1, A2, ...AN), pero no de ninguno de sus subconjuntos.
    
    Es decir, B depende de la combinaci√≥n completa de atributos, y no de un parte de la clave.
    
    DFC - Supuesto Comerciales
    
    Tenemos que las ventas dependen de la combinaci√≥n `comercialID, ciudad, provincia` y no de un subconjunto de ellas, es decir, `comercialID, ciudad, provincia ‚Üí ventas`.
    
- **Dependencia funcional transitiva** (DFT): se dice que hay un DFT entre A y C, si A ‚Üí B y B ‚Üí C, siendo B y C columnas no claves. Dicho de otro modo, cuando tenemos columnas no claves que determinan otras columnas no clave.
    
    DFT - Supuesto Comerciales
    
    Tenemos que `comercialID ‚Üí comercialNom, estadoID, estadoDesc` y que `estadoID ‚Üí estadoDesc`, por lo que tenemos una dependencia transitiva de `comercialID` a `estadoDesc`, ya que `comercialID ‚Üí estadoID ‚Üí estadoDesc`.



??? example "Ejemplos de dependencias funcionales"

    <u>Ejemplo 1: El Gimnasio del Barrio - Entendiendo la **Dependencia Funcional**</u>

    En el gimnasio "Siempre en Forma", tienen una hoja de c√°lculo para registrar a sus miembros. Es muy sencilla.

    **Tabla: `MIEMBROS_GIMNASIO`**

    | ID_Socio | Nombre | Apellido | Fecha_Nacimiento | Tipo_Suscripcion |
    | :--- | :--- | :--- | :--- | :--- |
    | SOC-001 | Elena | Ram√≠rez | 1995-03-15 | Mensual |
    | SOC-002 | Marcos | Vidal | 1988-11-20 | Anual |
    | SOC-003 | Carla | Soler | 2001-07-30 | Mensual |

    Aqu√≠, el `ID_Socio` es √∫nico para cada persona. Pensemos como la base de datos:

    *   **Si te doy `SOC-001`, ¬øpuedes decirme el nombre?** S√≠, es Elena. No hay duda.
        *   `ID_Socio -> Nombre`
    *   **Si te doy `SOC-001`, ¬øpuedes decirme la `Fecha_Nacimiento`?** S√≠, 1995-03-15.
        *   `ID_Socio -> Fecha_Nacimiento`
    *   **Pero, si te digo que busques a la persona con suscripci√≥n "Mensual", ¬øpuedes darme un `ID_Socio` √∫nico?** No, porque tanto Elena como Carla tienen esa suscripci√≥n. Por lo tanto, `Tipo_Suscripcion` no determina el `ID_Socio`.

    **Conclusi√≥n del ejemplo:** La Dependencia Funcional es una regla de negocio que dice: "Este valor (o conjunto de valores) me sirve como una 'llave' para encontrar exactamente un solo valor de este otro campo". Aqu√≠, `ID_Socio` es la llave para todos los dem√°s datos del miembro.

    ---

    <u>Ejemplo 2: La Pizzer√≠a "Mamma Mia" - Descubriendo la **Dependencia Funcional Completa vs. Parcial**</u>

    La pizzer√≠a quiere registrar qu√© ingredientes extra a√±ade cada cliente a sus pizzas en cada pedido. Su tabla inicial es un desastre.

    **Tabla: `EXTRAS_PEDIDO`**

    | Nro_Pedido| Pizza_ID | Nombre_Pizza | Ingrediente_Extra | Precio_Extra |
    | :--- | :--- | :--- | :--- | :--- |
    | 1001 | P01 | Margarita | Champi√±ones | 1.50 |
    | 1001 | P01 | Margarita | Aceitunas | 1.00 |
    | 1001 | P02 | Barbacoa | Doble Queso | 2.00 |
    | 1002 | P01 | Margarita | Champi√±ones | 1.50 |

    La clave para identificar una l√≠nea de forma √∫nica es la combinaci√≥n de `{Nro_Pedido, Pizza_ID, Ingrediente_Extra}`. ¬°Una clave de tres columnas!

    Ahora, analicemos qu√© depende de qu√©:

    1.  **Dependencia del `Precio_Extra`**: ¬øCu√°nto cuesta el extra "Champi√±ones"? Cuesta 1.50. ¬øNecesito saber el n√∫mero de pedido para saber eso? No. ¬øNecesito saber el tipo de pizza? No. El precio del extra solo depende del ingrediente en s√≠.
        *   `Ingrediente_Extra -> Precio_Extra`
        Esta es una **dependencia parcial**, porque `Precio_Extra` depende de `Ingrediente_Extra`, que es solo un trocito de nuestra larga clave primaria.

    2.  **Dependencia del `Nombre_Pizza`**: Para saber que la "P01" es una "Margarita", ¬ønecesito el n√∫mero de pedido o el ingrediente? No, solo necesito el `Pizza_ID`.
        *   `Pizza_ID -> Nombre_Pizza`
        Esta es otra **dependencia parcial**. `Nombre_Pizza` depende de `Pizza_ID`, que es otra parte de la clave.

    **¬øExiste alguna dependencia completa aqu√≠?** En esta tabla, tal como est√° dise√±ada, no hay ning√∫n atributo que necesite las tres partes de la clave para ser determinado. Esto nos indica que el dise√±o es muy deficiente y necesita ser descompuesto. Por ejemplo, si a√±adi√©ramos un campo `Comentario_Cliente` ("sin cortar"), ese campo s√≠ podr√≠a depender de la clave completa: `{Nro_Pedido, Pizza_ID, Ingrediente_Extra} -> Comentario_Cliente`, porque el comentario es espec√≠fico para un ingrediente en una pizza de un pedido concreto.

    **Conclusi√≥n del ejemplo:** Una dependencia es completa solo si necesita **todos** los componentes de la clave compuesta para funcionar. Si le sobra aunque sea uno, es parcial. Las dependencias parciales son una se√±al de alarma que nos grita: "¬°Divide esta tabla!".

    ---

    <u>Ejemplo 3: La Academia de Idiomas - Identificando la **Dependencia Funcional Transitiva**</u>

    La academia "Polyglot" registra los cursos en los que se matriculan sus estudiantes.

    **Tabla: `MATRICULAS`**

    | ID_Matricula | ID_Estudiante| Nombre_Estudiante | ID_Curso | Nivel_Curso | ID_Profesor | Nombre_Profesor |
    | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
    | MAT-01 | EST-12 | Ana Sanz | ING-B1 | Intermedio | PROF-J | John Smith |
    | MAT-02 | EST-15 | Luis Prado | FRA-A2 | B√°sico | PROF-S | Sophie Dubois |
    | MAT-03 | EST-12 | Ana Sanz | FRA-A2 | B√°sico | PROF-S | Sophie Dubois |

    La clave primaria que identifica cada acto de matriculaci√≥n es `ID_Matricula`.

    Vamos a seguir la cadena de dependencias:

    1.  `ID_Matricula` determina el estudiante (`ID_Estudiante`) y el curso (`ID_Curso`). ¬°Correcto!
        *   `ID_Matricula -> ID_Estudiante`
        *   `ID_Matricula -> ID_Curso`

    2.  Ahora bien, `Nombre_Estudiante` no depende directamente de la matr√≠cula, sino del estudiante.
        *   `ID_Estudiante -> Nombre_Estudiante`

    3.  Y aqu√≠ viene lo interesante. El profesor asignado (`ID_Profesor` y `Nombre_Profesor`) no depende de la matr√≠cula en s√≠, sino del curso impartido. Cada curso tiene un profesor asignado.
        *   `ID_Curso -> ID_Profesor`
        *   `ID_Profesor -> Nombre_Profesor`

    ¬°Hemos encontrado la transitividad!

    *   `ID_Matricula` (la clave) -> `ID_Curso` (atributo no clave)
    *   `ID_Curso` (atributo no clave) -> `Nombre_Profesor` (atributo no clave)

    El `Nombre_Profesor` depende de la `ID_Matricula`, pero de forma **indirecta**, a trav√©s del `ID_Curso`. Esto es una **dependencia transitiva**.

    **¬øCu√°l es el peligro?** Si la profesora Sophie Dubois se va de la academia y es reemplazada por "Pierre Martin" en el curso FRA-A2, tendr√≠amos que buscar todas las matr√≠culas de ese curso (la de Luis, la de Ana y la de cualquier otro alumno) para actualizar el nombre del profesor. Si nos dejamos una sola fila sin actualizar, tendremos datos inconsistentes.

    **Conclusi√≥n del ejemplo:** La dependencia transitiva es como un "amigo de un amigo". Un atributo no clave no deber√≠a darnos informaci√≥n sobre otro atributo no clave. Cada concepto (estudiantes, cursos, profesores) deber√≠a tener su propia tabla para evitar estas peligrosas dependencias en cadena.

    _El objetivo final de identificar estas dependencias es guiarnos para crear un dise√±o de base de datos normalizado, donde cada pieza de informaci√≥n est√© en su lugar l√≥gico y solo en uno._


### Formas Normales

![](images/03FN.png "Formas normales"){ width="40%" align="right" }

La normalizaci√≥n consiste en una serie de pasos, cada uno de los cuales se corresponde a una forma normal (FN). Conforme se va avanzando en la normalizaci√≥n, las tablas tienen una estructura m√°s limpia y con menor redundancia.

_Codd_ propuso en 1972 tres formas normales, a las que se sum√≥ la forma normal de _Boyce-Codd_ en 1974, y luego se a√±adieron dos m√°s por parte de _Fagin_ entre 1977 y 1979. En este curso, nos vamos a centrar en las tres primeras, que cubren la mayor√≠a de casos con los que nos vamos a encontrar, ya que se considera que una base de datos que est√° en 3FN es una base de datos correctamente dise√±ada

Todas las formas normales se construyen sobre una forma normal previa, de forma que se anidan unas dentro de otras:

- **1FN**: Una relaci√≥n est√° en primera forma normal si, y s√≥lo si, todos sus dominios contienen valores at√≥micos. Supone la eliminaci√≥n de todos los campos multivaluados.
    
    Por lo general, si tenemos una tabla de un modelo relacional, por las propias restricciones sem√°nticas del modelo relacional, no deber√≠amos tener ning√∫n campo con varios valores, ya que deber√≠an haberse transformado en relaciones 1:N.
    
    1FN - Supuesto Comerciales
    
    Como ninguna columna tiene m√°s de un valor, la tabla ya est√° en 1FN.

    !!! abstract "1FN - Supuesto Comerciales"

        Como ninguna columna tiene m√°s de un valor, la tabla ya est√° en 1FN.
    
- **2FN**: una relaci√≥n est√° en segunda forma normal si est√° en 1FN y todas las columnas que no son clave tienen un DFC de la clave primaria.
    
    Para ello, descompondremos la tabla en varias subtablas, y comprobaremos que ning√∫n subconjunto de los atributos no clave determinan campos no principales.
    
    Si todas las claves candidatas de las tablas en 1FN son simples (unitarias), autom√°ticamente las tablas ya est√°n en 2FN. En cambio, si la clave primaria es compuesta, deberemos comprobar que todos los atributos dependen de la clave primaria compuesta y no de un subconjunto de esta.

    ??? abstract "2FN - Supuesto Comerciales"

        Si revisamos las dependencia funcionales, hemos de comprobar que todos los atributos no clave dependan de toda la clave primaria. Para ello, necesitamos crear al menos tres tablas:

        `**COMERCIAL** (comercialID, comercialNom, estadoID, estadoDesc)`<br>
        `¬∑ PK: (codigo)`<br><br>

        `**CIUDAD** (ciudad, provincia, ciudadPob, provinciaPob)`<br><br>
        `¬∑ PK: (ciudad)`

        `**REGISTRO** (comercialID*, ciudad*, provincia*, ventas)`
        `¬∑ PK: (comercialID, ciudad, provincia)   ¬∑ FK: (comercialID) ‚Üí COMERCIAL   ¬∑ FK: (ciudad, provincia) ‚Üí CIUDAD`<br><br>

        Dando como resultado las siguientes tablas con datos:

        - `COMERCIAL`
            
            | comercialID | comercialNom | estadoID | estadoDesc |
            | --- | --- | --- | --- |
            | C1 | Carlos Suarez | JC | Jornada Completa |
            | C2 | Manoli Campos | JC | Jornada Completa |
            | C3 | Carlos Suarez | JPM | Jornada Partida Ma√±anas |
            | C4 | Sonia S√°nchez | JPT | Jornada Partida Tardes |
            | C5 | Marina Vidal | JC | Jornada Completa |
            | C6 | Michael Johnson | JC | Jornada Completa |
            
        - `CIUDAD`
            
            | ciudad | provincia | ciudadPob | provinciaPob |
            | --- | --- | --- | --- |
            | Elche | Alicante | 230.000 | 1.800.000 |
            | Denia | Alicante | 42.000 | 1.800.000 |
            | Aspe | Alicante | 22.000 | 1.800.000 |
            | Cartagena | Murcia | 218.000 | 1.520.000 |
            | Gand√≠a | Valencia | 73.000 | 2.550.000 |
            | Valencia | Valencia | 807.000 | 1.800.000 |
            | Valencia | California | 63.000 | 38.940.000 |
            
        - `REGISTRO`
            
            | comercialID`*` | ciudad`*` | provincia`*` | ventas |
            | --- | --- | --- | --- |
            | C1 | Elche | Alicante | 33 |
            | C1 | Denia | Alicante | 22 |
            | C2 | Elche | Alicante | 55 |
            | C2 | Aspe | Alicante | 44 |
            | C3 | Cartagena | Murcia | 17 |
            | C4 | Gand√≠a | Valencia | 27 |
            | C5 | Valencia | Valencia | 37 |
            | C6 | Valencia | California | 47 |

- **3FN**: 2FN + todo atributo que no es clave primaria no tiene una dependencia funcional transitiva de otro atributo no clave, es decir, depende √∫nicamente de la clave primaria de modo no transitivo.

    ??? abstract "3FN - Supuesto Comerciales"

        Ahora revisamos que no haya atributos que dependan de forma transitiva de la clave primaria. Tanto `COMERCIAL.estadoDesc` como `CIUDAD.provinciaPob` dependen de forma transitiva de un atributo no que es clave en sus tablas (`COMERCIAL.estadoID` y `CIUDAD.provincia`, respectivamente). Es decir, tenemos las DFT `comercialID ‚Üí estadoID ‚Üí estadoDesc` y `ciudad ‚Üí provincia ‚Üí provinciaPob`.

        As√≠ pues, para deshacer las dependencias funcionales transitivas dividimos las tablas `COMERCIAL` y `CIUDAD` en dos nuevas tablas (`ESTADO`y `PROVINCIA`):

        `**ESTADO** (estadoID, estadoDesc)`<br>
        `¬∑ PK: (codigo)`

        `**COMERCIAL** (comercialID, comercialNom, estadoID*)`<br>
        `¬∑ PK: (codigo)   ¬∑ FK: (estadoID) ‚Üí ESTADO`
        <br>
        `**PROVINCIA** (provincia, provinciaPob)`<br>
        `¬∑ PK: (provincia)`

        `**CIUDAD** (ciudad, provincia*, ciudadPob)`<br>
        `¬∑ PK: (ciudad)   ¬∑ FK: (provincia) ‚Üí PROVINCIA`<br>

        `**REGISTRO** (comercialID*, ciudad*, provincia*, ventas)`<br>
        `¬∑ PK: (comercialID, ciudad, provincia)`<br>
        `¬∑ FK: (comercialID) ‚Üí COMERCIAL`<br>
        `¬∑ FK: (ciudad, provincia) ‚Üí CIUDAD`<br>

        Dando como resultado las siguientes tablas con datos:

        <div class="grid cards" markdown>

        - `ESTADO`
            
            | estadoID | estadoDesc |
            | --- | --- |
            | JC | Jornada Completa |
            | JPM | Jornada Partida Ma√±anas |
            | JPT | Jornada Partida Tardes |
            
        - `COMERCIAL`
            
            | comercialID | comercialNom | estadoID`*` |
            | --- | --- | --- |
            | C1 | Carlos Suarez | JC |
            | C2 | Manoli Campos | JC |
            | C3 | Carlos Suarez | JPM |
            | C4 | Sonia S√°nchez | JPT |
            | C5 | Marina Vidal | JC |
            | C6 | Michael Johnson | JC |
            
        - `PROVINCIA`
            
            | provincia | provinciaPob |
            | --- | --- |
            | Alicante | 1.800.000 |
            | Murcia | 1.520.000 |
            | Valencia | 2.550.000 |
            | California | 38.940.000 |
            
        - `CIUDAD`
            
            | ciudad | provincia`*` | ciudadPob |
            | --- | --- | --- |
            | Elche | Alicante | 230.000 |
            | Denia | Alicante | 42.000 |
            | Aspe | Alicante | 22.000 |
            | Cartagena | Murcia | 218.000 |
            | Gand√≠a | Valencia | 73.000 |
            | Valencia | Valencia | 807.000 |
            | Valencia | California | 63.000 |
            
        - `REGISTRO`
            
            | comercialID`*` | ciudad`*` | provincia`*` | ventas |
            | --- | --- | --- | --- |
            | C1 | Elche | Alicante | 33 |
            | C1 | Denia | Alicante | 22 |
            | C2 | Elche | Alicante | 55 |
            | C2 | Aspe | Alicante | 44 |
            | C3 | Cartagena | Murcia | 17 |
            | C4 | Gand√≠a | Valencia | 27 |
            | C5 | Valencia | Valencia | 37 |
            | C6 | Valencia | California | 47 |


        </div>

    El problema de la 3FN es que no maneja relaciones que:

    - Tienen varias claves candidatas,
    - Esas claves candidatas son compuestas, y
    - Las claves candidatas tienen por lo menos un atributo en com√∫n.
    <br><br>

- **FNBC**: Es una mejora de la 3FN donde, si tenemos m√°s de una clave candidata y estas son compuestas y comparten alg√∫n atributo entonces, ning√∫n atributo, sea clave o no, puede depender de algo que no sea la clave primaria.

    Si la clave no es compuesta y no existe m√°s de una clave candidata (s√≥lo tenemos la clave primaria), la FNBC es equivalente a la 3FN.

    El objetivo de la FNBC es asegurar que cada dato de una tabla depende √∫nicamente de una clave real y completa, y no de otra cosa.

    ??? abstract "FNBC - Supuesto Comerciales"

        En nuestro caso, no tenemos m√°s de una clave candidata, por lo que la FNBC es equivalente a la 3FN.


!!! tip "En resumen"

    En la pr√°ctica, cuando todas las tablas est√°n en FNBC, se puede considerar que la base de datos est√° totalmente normalizada. Una tabla en FNBC ya est√° desde 1FN hasta 3FN y tiene las siguientes caracter√≠sticas:

    - Tiene una clave primaria.
    - No tiene columnas multivaluadas.
    - Todas las columnas dependen de una clave pero nada m√°s.
    - No contiene ninguna dependencia transitiva.

    <figure markdown="span">
        <img src="images/03normalizacion.png" width="90%">
        <figcaption>Proceso de normalizaci√≥n</figcaption>
    </figure>


### Ejemplo Paso a Paso


??? example "Ejemplo 1: Paso a paso. Consultora de software"

    Una peque√±a consultora de software, "C√≥digo Veloz", registra los datos de los proyectos en una √∫nica tabla. Vuestro objetivo es sanear y normalizar esta tabla para evitar problemas de redundancia e inconsistencia.

    **Normalizaci√≥n de una Tabla de Proyectos**

    Una peque√±a consultora de software, "C√≥digo Veloz", registra los datos de los proyectos en una √∫nica tabla. Vuestro objetivo es sanear y normalizar esta tabla para evitar problemas de redundancia e inconsistencia.

    <u>La Tabla Inicial: `PROYECTOS_DESORDENADOS`</u>

    | ID\_Proyecto| Nombre\_Proyecto| ID\_Empleado | Nombre\_Empleado| Horas\_Trabajadas| ID\_Departamento| Jefe\_Departamento| Salario\_Base\_Empleado |
    | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
    | P100 | App M√≥vil | E01 | Juan P√©rez | 100 | D01 | Ana Torres | 40.000 |
    | P100 | App M√≥vil | E02 | Mar√≠a Sol | 80 | D01 | Ana Torres | 55.000 |
    | P200 | Web Cliente | E01 | Juan P√©rez | 120 | D01 | Ana Torres | 40.000 |
    | P300 | Sistema IA | E03 | Luis Rey | 90 | D02 | Pedro Soto | 60.000 |

    <u>Paso 0: Identificaci√≥n de Dependencias y Clave</u>

    Antes de empezar, asumimos que esta tabla ya est√° en **Primera Forma Normal (1FN)**, pues no hay grupos repetitivos ni atributos multivaluados (cada celda contiene un solo valor at√≥mico).

    1.  **Clave Primaria (CP):** Para identificar de forma √∫nica cada fila (es decir, las horas que *un* empleado dedic√≥ a *un* proyecto), necesitamos la combinaci√≥n: `{ID_Proyecto, ID_Empleado}`.

    2.  **Dependencias Funcionales (DFs) Observadas:**
        *   `ID_Proyecto -> Nombre_Proyecto` (El ID del proyecto determina su nombre).
        *   `ID_Empleado -> Nombre_Empleado, ID_Departamento, Salario_Base_Empleado` (El ID del empleado determina sus datos personales y salariales).
        *   `ID_Departamento -> Jefe_Departamento` (El departamento determina qui√©n es su jefe).

    ---

    <u>Paso 1: De 1FN a 2FN (Eliminar Dependencias Parciales)</u>

    **REGLA DE LA 2FN:** Todos los atributos no clave deben ser completamente dependientes de **toda** la Clave Primaria.

    *Identificando las dependencias parciales:*

    1.  `ID_Proyecto -> Nombre_Proyecto`: El nombre del proyecto depende solo de `ID_Proyecto` (una parte de la clave). **Dependencia Parcial.**
    2.  `ID_Empleado -> Nombre_Empleado, ID_Departamento, Salario_Base_Empleado`: Los datos del empleado dependen solo de `ID_Empleado` (otra parte de la clave). **Dependencia Parcial.**

    *Acci√≥n: Descomponer la tabla para eliminar las dependencias parciales.*

    **Tabla 1.1: `ASIGNACION_PROYECTO`** (Retiene la clave primaria original y los atributos que dependen de ella de forma COMPLETA).
    *   **DF Remanente:** `{ID_Proyecto, ID_Empleado} -> Horas_Trabajadas`
    *   **CP:** `{ID_Proyecto, ID_Empleado}`

    | ID\_Proyecto| ID\_Empleado| Horas\_Trabajadas |
    | :--- | :--- | :--- |
    | P100 | E01 | 100 |
    | P100 | E02 | 80 |
    | P200 | E01 | 120 |
    | P300 | E03 | 90 |

    **Tabla 1.2: `PROYECTOS`** (Extrae la informaci√≥n que solo depende de `ID_Proyecto`).
    *   **DF Remanente:** `ID_Proyecto -> Nombre_Proyecto`
    *   **CP:** `{ID_Proyecto}`

    | ID\_Proyecto| Nombre\_Proyecto |
    | :--- | :--- |
    | P100 | App M√≥vil |
    | P200 | Web Cliente |
    | P300 | Sistema IA |

    **Tabla 1.3: `EMPLEADOS`** (Extrae la informaci√≥n que solo depende de `ID_Empleado`).
    *   **DF Remanente:** `ID_Empleado -> Nombre_Empleado, ID_Departamento, Salario_Base_Empleado`
    *   **CP:** `{ID_Empleado}`

    | ID\_Empleado| Nombre\_Empleado| ID\_Departamento| Jefe\_Departamento | Salario\_Base\_Empleado |
    | :--- | :--- | :--- | :--- | :--- |
    | E01 | Juan P√©rez | D01 | Ana Torres | 40.000 |
    | E02 | Mar√≠a Sol | D01 | Ana Torres | 55.000 |
    | E03 | Luis Rey | D02 | Pedro Soto | 60.000 |

    **Resultado:** Las tres tablas est√°n ahora en **2FN**.

    ---

    <u>Paso 2: De 2FN a 3FN (Eliminar Dependencias Transitivas)</u>

    **REGLA DE LA 3FN:** No debe existir ninguna dependencia funcional transitiva. Un atributo no clave no puede depender de otro atributo no clave.

    *Identificando las dependencias transitivas:*

    Revisamos las tablas 1.1 y 1.2 (que ya est√°n perfectas) y nos centramos en la **Tabla 1.3: `EMPLEADOS`**.

    *   **DF Observada:** `ID_Departamento -> Jefe_Departamento`
    *   **An√°lisis:**
        *   `ID_Empleado` es la clave primaria.
        *   `ID_Departamento` es un atributo no clave.
        *   `Jefe_Departamento` es un atributo no clave.
        *   El `Jefe_Departamento` depende de `ID_Departamento`, que a su vez depende de la clave primaria (`ID_Empleado`). ¬°**Dependencia Transitiva**!
        *   `ID_Empleado -> ID_Departamento -> Jefe_Departamento`

    *Acci√≥n: Crear una nueva tabla para romper la cadena transitiva.*

    **Tabla 2.1: `DEPARTAMENTOS`** (Extrae la informaci√≥n de la dependencia transitiva).

    *   **DF Remanente:** `ID_Departamento -> Jefe_Departamento`
    *   **CP:** `{ID_Departamento}`

    | ID\_Departamento| Jefe\_Departamento |
    | :--- | :--- |
    | D01 | Ana Torres |
    | D02 | Pedro Soto |

    **Tabla 2.2: `EMPLEADOS_NORMALIZADOS`** (Actualiza la tabla de empleados).

    *   **DF Remanente:** `ID_Empleado -> Nombre_Empleado, ID_Departamento, Salario_Base_Empleado`
    *   **CP:** `{ID_Empleado}`

    | ID\_Empleado| Nombre\_Empleado| ID\_Departamento| Jefe\_Departamento | Salario\_Base\_Empleado |
    | :--- | :--- | :--- | :--- | :--- |
    | E01 | Juan P√©rez | D01 | Ana Torres | 40.000 |
    | E02 | Mar√≠a Sol | D01 | Ana Torres | 55.000 |
    | E03 | Luis Rey | D02 | Pedro Soto | 60.000 |

    **Resultado:** Ahora tenemos cuatro tablas (ASIGNACION_PROYECTO, PROYECTOS, DEPARTAMENTOS, EMPLEADOS_NORMALIZADOS) que est√°n en **3FN**.

    ---

    <u>Paso 3: De 3FN a FNBC (Boyce-Codd)</u>

    **REGLA DE LA FNBC:** Para cada dependencia funcional no trivial $X \rightarrow A$, $X$ debe ser una **superclave** (o sea, una clave candidata o un conjunto de atributos que la contienen).

    En la mayor√≠a de los casos de la vida real, si una tabla est√° en 3FN, tambi√©n lo estar√° en FNBC. La FNBC solo es m√°s estricta cuando existen **m√∫ltiples claves candidatas que se solapan**.

    *Identificando la posibilidad de FNBC:*

    Revisamos las cuatro tablas para buscar dependencias donde el determinante ($X$) no sea una superclave:

    1.  **`ASIGNACION_PROYECTO`**: DF: `{ID_Proyecto, ID_Empleado} -> Horas_Trabajadas`. El determinante es la CP. **OK**.
    2.  **`PROYECTOS`**: DF: `ID_Proyecto -> Nombre_Proyecto`. El determinante es la CP. **OK**.
    3.  **`DEPARTAMENTOS`**: DF: `ID_Departamento -> Jefe_Departamento`. El determinante es la CP. **OK**.
    4.  **`EMPLEADOS_NORMALIZADOS`**: DF: `ID_Empleado -> Nombre_Empleado, ID_Departamento, Salario_Base_Empleado`. El determinante es la CP. **OK**.

    **¬°PERO ESPERA!** ¬øQu√© pasar√≠a si la regla de negocio fuera: *Cada Salario Base determina un Nivel de Empleado, y solo los Jefes de Departamento pueden tener un Nivel 5*?

    *   Si a√±adi√©ramos un atributo `Nivel_Empleado` a la tabla `EMPLEADOS_NORMALIZADOS` y existiera la DF: `Salario_Base_Empleado -> Nivel_Empleado` (donde $X$ no es la clave), esto podr√≠a forzarnos a aplicar FNBC.

    *Ejemplo Hipot√©tico para romper FNBC (No aplica al caso anterior, pero es did√°ctico):*

    Imaginemos que en la tabla de empleados existe una regla donde el **Nombre del Empleado** debe ser √∫nico. Tendr√≠amos dos claves candidatas: `ID_Empleado` y `Nombre_Empleado`.

    *   **Claves Candidatas (CC):** `{ID_Empleado}` y `{Nombre_Empleado}`
    *   **DFs:** `ID_Empleado -> Nombre_Empleado` y `Nombre_Empleado -> ID_Empleado`

    Si existiera la DF: `Nombre_Empleado -> Salario_Base_Empleado`. El determinante (`Nombre_Empleado`) es una clave candidata (Superclave). **Por lo tanto, sigue estando en FNBC.**

    **Conclusi√≥n del ejercicio:** En este caso pr√°ctico, al llegar a la **3FN** hemos satisfecho todos los requisitos de la **FNBC**.

    RESUMEN FINAL DE LAS TABLAS NORMALIZADAS (FNBC)

    | Tabla | Clave Primaria (CP) | Atributos | Dependencias Funcionales |
    | :--- | :--- | :--- | :--- |
    | **ASIGNACION_PROYECTO** | `{ID_Proyecto, ID_Empleado}` | `Horas_Trabajadas` | **Completa:** `{ID_Proyecto, ID_Empleado} -> Horas_Trabajadas` |
    | **PROYECTOS** | `ID_Proyecto` | `Nombre_Proyecto` | `ID_Proyecto -> Nombre_Proyecto` |
    | **DEPARTAMENTOS** | `ID_Departamento` | `Jefe_Departamento` | `ID_Departamento -> Jefe_Departamento` |
    | **EMPLEADOS** | `ID_Empleado` | `Nombre_Empleado, ID_Departamento, Salario_Base_Empleado` | `ID_Empleado -> Nombre_Empleado, ID_Departamento, Salario_Base_Empleado` |

    ¬°Con esto, hemos pasado de una tabla redundante y propensa a errores a un modelo relacional s√≥lido, limpio y eficiente! Recordad, la normalizaci√≥n es la clave para la integridad de vuestros datos.


### Desnormalizaci√≥n

El concepto de **desnormalizar** un modelo relacional consiste en transformar una base de datos a una forma normal menor, siempre con el objetivo de mejorar el rendimiento de las operaciones de consulta de datos, a costa de aceptar cierta redundancia de datos

Por ejemplo, podemos unir varias relaciones en una si se usan juntas frecuentemente mediante operaciones _join_.

Adem√°s del rendimiento en las consultas, podemos desnormalizar nuestros modelos para simplificar el esquema o reducir la complejidad de ciertas consultas.

Un caso muy com√∫n es unir los datos de dos tablas que tienen una relaci√≥n 1:1 en una √∫nica tabla (siempre que la sem√°ntica de las relaciones lo permita).


---

## Referencias

- Herramienta gr√°fica [ERDPlus](https://erdplus.com/) para la realizaci√≥n de diagramas de modelos relacionales.
    
- Materiales sobre el m√≥dulo de BD:
    
    - _[Model Relacional](https://ioc.xtec.cat/materials/FP/Recursos/fp_dam_m02_/web/fp_dam_m02_htmlindex/WebContent/u3/a1/continguts.html) - Institut Obert de Catalunya_
    - [Modelo Relacional](https://jorgesanchez.net/manuales/gbd/modelo-relacional.html) de _Jorge S√°nchez_
    - [Bases de datos relacionales](https://apuntes-daw.javiergutierrez.trade/bases-de-datos/ut3/recopila.html) de _Javier Guti√©rrez_
    - [Dise√±o de modelo l√≥gicos normalizados](https://gestionbasesdatos.readthedocs.io/es/latest/Tema2/index.html) de gestionbasesdatos.readthedocs.io
    - [Dise√±o l√≥gico](https://www.cs.us.es/cursos/bd-2023/temas/BD-Tema-2.pdf) y [Normalizaci√≥n](https://www.cs.us.es/cursos/bd-2023/temas/BD-Tema-6.pdf) de la _Universidad de Sevilla_