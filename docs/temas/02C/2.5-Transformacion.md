# **2.5. Transformaci√≥n del modelo ER a MR**

üëâ **Pasos**

Una vez conocido el modelo conceptual entidad-relaci√≥n y el modelo l√≥gico relacional, vamos a estudiar como transformar y pasar de uno a otro. Para ello, seguiremos los siguientes pasos:

- Entidades  ‚Üí  Tablas
- Atributos  ‚Üí  Columnas
- Atributos identificadores  ‚Üí  Claves primarias
- Atributos de relaciones  ‚Üí  Columnas detr√°s de claves ajenas
- Relaciones  ‚Üí  Claves ajenas y/o tablas

!!! tip "Resumen de transformaci√≥n"

    > **Transformaci√≥n General**

    | Elemento Modelo ER | Transformaci√≥n a Modelo Relacional (Tablas) | Tratamiento de Claves y Cardinalidad (Reglas) |
    | :--- | :--- | :--- |
    | **Entidad Fuerte** | Cada entidad se convierte en una tabla. | La clave primaria (PK) de la tabla es el identificador de la entidad. Los dem√°s atributos son columnas. |
    | **Entidad D√©bil** | Cada entidad d√©bil se convierte en una tabla. | La PK de la tabla es compuesta: la PK de la entidad fuerte propietaria (como FK) + el discriminante de la entidad d√©bil. |
    | **Relaci√≥n 1 a 1 (1:1)** | Se a√±ade una clave for√°nea (FK) en una de las dos tablas. | ‚Ä¢ La columna FK debe tener **siempre** una restricci√≥n **UNIQUE**.<br>‚Ä¢ **Regla de Ubicaci√≥n (para evitar NULLs):** Si la cardinalidad es `(1,1)` en un lado y `(0,1)` en el otro, la FK **siempre se coloca en la tabla del lado `(0,1)`**. De este modo, la FK puede ser declarada como **NOT NULL**.<br>‚Ä¢ Si la cardinalidad es `(0,1)` en ambos lados, la FK puede ir en cualquiera de las dos tablas y **debe admitir NULL**.|
    | **Relaci√≥n 1 a Muchos (1:N)** | No se crea una tabla nueva para la relaci√≥n. | La PK de la entidad del lado "1" migra a la tabla de la entidad del lado "N" como una FK. Si la participaci√≥n m√≠nima del lado "1" es 0, la FK admite **NULL**. Si es 1, es **NOT NULL**. |
    | **Relaci√≥n Muchos a Muchos (M:N)** | **Siempre** se crea una nueva tabla intermedia para la relaci√≥n. | ‚Ä¢ La tabla intermedia contiene como FK las PK de las dos entidades que relaciona.<br>‚Ä¢ **Si la relaci√≥n tiene atributos propios, estos se convierten en columnas adicionales** en esta misma tabla intermedia.<br>‚Ä¢ La PK de la nueva tabla es, por lo general, la **combinaci√≥n de ambas FK** (y a veces, tambi√©n de alg√∫n atributo de la relaci√≥n si es necesario para garantizar la unicidad). |
    | **Relaci√≥n Reflexiva 1:1** | Se a√±ade una columna en la propia tabla. | La columna es una FK que referencia a la PK de la misma tabla. Debe tener la restricci√≥n **UNIQUE** y ser **NULLABLE**. |
    | **Relaci√≥n Reflexiva 1:N** | Se a√±ade una columna en la propia tabla. | La columna es una FK que referencia a la PK de la misma tabla (Ej: `id_jefe` en la tabla `EMPLEADO`). Es **NULLABLE**. |
    | **Relaci√≥n Reflexiva M:N** | Se crea una nueva tabla intermedia. | La tabla intermedia tiene **dos columnas FK**, ambas referenciando a la PK de la tabla original. Sus atributos (si los tiene) tambi√©n van en esta tabla. |


    > **Transformaci√≥n de Jerarqu√≠as (Generalizaci√≥n / Especializaci√≥n - ISA)**

    | Estrategia de Transformaci√≥n | Descripci√≥n de las Tablas Resultantes | Cu√°ndo Usarla (Ventajas / Desventajas) |
    | :--- | :--- | :--- |
    | **1. Una Sola Tabla (Todo en la Superclase)** | Se crea **una √∫nica tabla** para la superclase que contiene todos los atributos (comunes y espec√≠ficos de todas las subclases). Se a√±ade una columna "tipo" para discriminar. | **Ventaja:** Consultas r√°pidas (no se necesitan JOINs).<br>**Desventaja:** Mucho espacio desperdiciado por valores **NULL** en atributos no aplicables. |
    | **2. Tabla por cada Subclase (Herencia Concreta)** | Se crea **una tabla por cada subclase concreta** (hija). No hay tabla para la superclase (padre). Cada tabla hija repite los atributos comunes adem√°s de los suyos espec√≠ficos. | **Ventaja:** No hay valores NULL. Consultas a una subclase son directas.<br>**Desventaja:** Los atributos comunes est√°n duplicados. Consultar sobre *todos* los tipos requiere uniones (`UNION`). |
    | **3. Tabla por cada Clase (Herencia de Tablas)** | Se crea **una tabla para la superclase** con los atributos comunes y **una tabla por cada subclase** con solo sus atributos espec√≠ficos. La PK de la superclase migra como PK y FK a las tablas hijas. | **Ventaja:** Modelo m√°s normalizado y fiel al ER. Sin redundancia ni NULLs excesivos.<br>**Desventaja:** Las consultas a menudo requieren **JOINs** entre la tabla padre y la hija, lo que puede ser m√°s lento. |

    > **Transformaci√≥n de Agregaciones**

    | Elemento ER | Concepto Clave | Transformaci√≥n a Modelo Relacional |
    | :--- | :--- | :--- |
    | **Agregaci√≥n** | Una agregaci√≥n trata una **relaci√≥n existente como si fuera una entidad abstracta** para poder participar en otra relaci√≥n de nivel superior. | **Paso 1:** Se transforma la relaci√≥n interna (la que es agregada) siguiendo las reglas normales (ej. si es M:N, se crea una tabla intermedia `T_Interna`).<br><br>**Paso 2:** Se transforma la relaci√≥n externa (la que conecta con la agregaci√≥n). Para ello, la clave primaria de la tabla `T_Interna` migra como FK a la tabla de la entidad externa (si es 1:N) o a una nueva tabla intermedia (si es M:N). |

---


## üìÅ Atributos

Conviene recordar que dentro de una tabla, no se puede repetir el nombre de ning√∫n atributo, pero s√≠ en tablas diferentes.

Algunos profesionales prefieren que no se repitan los identificadores entre diferentes tablas de una misma BD, aunque es cierto que las herramientas ORM de generaci√≥n de modelos f√≠sicos a partir de definici√≥n de clases u objetos suelen nombrar todas las claves primarias como `id` o `_id`.

En cuanto a los atributos **compuestos**, se separan como atributos individuales dentro de la tabla, pudi√©ndoles poner el prefijo del atributo compuesto o el propio nombre del atributo si no da pie a confusi√≥n.

Para los atributos **derivados**, dependiendo del caso, bien no se a√±aden como atributo (ya que se obtendr√°n a partir de los datos de las relaciones), o bien se renombra el atributo para almacenar el dato en crudo sobre el cual se realiza el c√°lculo necesario.

![](images/04atributos.png "Transformaci√≥n de atributos"){ align="right" width="40%"}

**Transformaci√≥n de atributos**

Por ejemplo, si partimos de un sencillo modelo ER de un cliente, su transformaci√≥n al modelo relacional ser√≠a la siguiente:

`**CLIENTE** (dni, nombre, calle, numPiso, ciudad, fnac)`<br>
`¬∑ PK: (dni)`

Destacar que no hemos puesto el nombre del atributo compuesto, sino cada uno de sus atributos, y adem√°s, hemos renombrado `numero` a `numPiso` para evitar confusiones con otras entidades; respecto al atributo derivado edad, lo hemos cambiado por la fecha de nacimiento.

Respecto a los atributos **multivaluados**, derivan en una relaci√≥n uno a muchos (1:N), tal como veremos a continuaci√≥n.

### Claves compuestas

Normalmente, cada entidad tendr√° un atributo identificador que traduciremos en una clave primaria. Pero puede darse el caso que una entidad tenga una clave compuesta, o tenga marcados dos atributos identificadores (en este caso, uno ser√° la clave primaria y el otro ser√° una clave alternativa que marcaremos como √∫nica).

Por ejemplo, el siguiente diagrama representa un aula que se identifica mediante una clave compuesta:

![](images/04claves-compuestas.png "Clave primaria compuesta vs claves candidatas"){ align="left" width="55%"}

`**AULA** (edificio, numSala, numAsientos)`<br>
`¬∑ PK: (edificio, numSala)`

Sin embargo, tambi√©n podemos tener un empleado con dos atributos identificadores:

`**EMPLEADO** (codigo, nif, nombre, salario)`<br>
`¬∑ PK: (codigo)`<br>
`¬∑ UK: (nif)`<br>

## ‚ö° Transformaci√≥n de Relaciones (fuertes)

Al transformar las relaciones, dependiendo de la cardinalidad deberemos colocar la clave ajena en un lugar u otro.

Cada entidad se transforma en una tabla, donde los atributos de la entidad se convierten en columnas de la tabla, y el atributo identificador se convierte en la clave primaria de la tabla.

- **Entidades.** Las entidades pasan a ser tablas
- **Atributos**. Los atributos pasan a ser columnas o atributos de la tabla.
    - **Atributos identificadores**. Pasan a ser claves primarias o alternativas.
        - **Claves primarias**. Son aquellos atributos que identifican de forma √∫nica cada tupla de la tabla.
        - **Claves alternativas**. Son aquellos atributos que tambi√©n identifican de forma √∫nica cada tupla de la tabla, pero no son la clave primaria. Estos atributos tendr√°n las restricciones **UNIQUE** y **NOT NULL**.
    - **Atributos compuestos**. Se transforman en los atributos que los componen. Por ejemplo, si vi√©ramos un atributo compuesto que fuera Direcci√≥n, que estuviera formado por calle, n√∫mero, piso y puerta, se transformar√° en los atributos de la relaci√≥n calle, n√∫mero, piso y puerta.
    - **Atributos obligatorios**. Se convierten en atributos de la relaci√≥n con la restricci√≥n de NOT NULL, es decir no puede ser nulo.
    - **Atributos opcionales**. Pueden tomar valores nulos.
    - **Atributos multivaluados**. Se transforman en una nueva tabla, cuya clave primaria est√° formada por la clave primaria de la entidad en la que se sit√∫a el atributo multivaluado m√°s el nombre del atributo multivaluado. En ocasiones, si el atributo multivaluado no admite repeticiones, es suficiente √©ste como clave primaria.



### ‚ÜòÔ∏è Transforma relacion 1:N

La clave primaria de la entidad con cardinalidad m√°xima a 1 se incluye en la entidad con cardinalidad m√°xima N como clave ajena.

![](images/04relaciones1n.png "Transformaci√≥n de relaci√≥n 1:N"){ align="right" width="40%"}

`**A** (a0, a1, b0*)`<br>
`¬∑ PK: (a0)   ¬∑ FK: (b0) ‚Üí B`<br>

`**B** (b0, b1)`<br>
`¬∑ PK: (b0)`

De esta manera, tenemos que dado un registro en A, tendremos uno en B. Y dado un B, podemos tener muchos en A, cumpliendo la cardinalidad de uno a muchos.

!!! example "Ejemplo 2: Relaci√≥n 1:N. Personas y tel√©fonos"

    Por ejemplo, si tenemos un modelo donde, en vez de un atributo multivaluado, hemos creado una entidad para modelar que una persona puede tener muchos tel√©fonos:

    ![](images/04ejemplo1n.png "Ejemplo de relaci√≥n 1:N"){ align="left" width="30%"}

    Si aplicamos la transformaci√≥n reci√©n vista, obtenemos el siguiente esquema l√≥gico:

    `**PERSONA** (dni, nombre, direccion)`<br>
    `¬∑ PK: (dni)`<br><br>
    `**TELEFONO** (numero, propio, dni*)`<br>
    `¬∑ PK: (numero)`<br>
    `¬∑ FK: (dni) ‚Üí PERSONA`<br>

    Conviene recordar que la clave ajena ser√° la clave primaria que nos hemos traido desde la entidad con cardinalidad m√°xima a 1 (en este caso, llevamos la clave primaria de `PERSONA` a `TELEFONO`), de manera que el atributo `TELEFONO.dni` representa la relaci√≥n `TENER`.

    Las claves ajenas se colocan tras los atributos de cada tabla (en este caso, detr√°s de `numero` y `propio`), y normalmente, se nombran con el mismo nombre de la clave primaria. Si diera pie a confusi√≥n, es recomendable renombrarla pudiendo como sufijo el nombre de la tabla.

    Finalmente, si quisi√©ramos generar el diagrama relacional, obtendr√≠amos una gr√°fico similar al siguiente, donde se puede ver como desde `TELEFONO.dni` se conecta con `PERSONA.dni`:

    <figure markdown="span">
        <img src="images/04ejemplo1n-mr.png" width="80%">
        <figcaption>Esquema relacional en ERDPlus</figcaption>
    </figure>


> üí° Recordad la regla de integridad referencial del modelo relacional, donde cada valor de la clave ajena debe coincidir con un valor existente de la clave primaria a la que referencia (o ser nulo). De esta manera, no podemos tener un dni en la tabla TELEFONO que no exista previamente en la tabla PERSONA.


<div class="grid cards" markdown>

   - `PERSONA`
       
       | dni | nombre | direccion |
       | --- | --- | --- |
       | 11111111A | Pedro Casas | Calle Mayor, 1 |
       | 22222222B | Laura Garc√≠a | Avda Libertad, 33 |
       | 33333333C | Mireia Vidal | Paseo de la Estaci√≥n, 5 |
       
   - `TELEFONO`
       
       | numero | propio | dni`*` |
       | --- | --- | --- |
       | 636111111 | true | 22222222B |
       | 686222222 | true | 11111111A |
       | 666333333 | false | 11111111A |
       | 666444444 | true | --error: un telefono debe pertenecer a una persona-- |

</div>

!!! success "Renombrando claves ajenas"

    Aunque es muy com√∫n que el nombre del atributo que hace de clave ajena coincida con la clave primaria a la que apunta, podemos renombrarla y ponerle un nombre que facilite su comprensi√≥n.

    En el caso de la tabla `TELEFONO`, el campo `dni` hace referencia al titular del tel√©fono, no es que un tel√©fono tenga un dni. Podr√≠amos haber modelado la tabla renombrando el `TELEFONO.dni` como `TELEFONO.propietario` dando un valor sem√°ntico al atributo:

    `**TELEFONO** (numero, propio, propietario*)`<br>
    `¬∑ PK: (numero)`<br>
    `¬∑ FK: (propietario) ‚Üí PERSONA`<br>

    Lo que s√≠ es obligatorio es que los dominios de las claves ajenas y las claves primarias coincidan.

!!! tip "Atributos multivaluados"

    Cuando tenemos un atributo multivaluado, √©ste se mapea en una relaci√≥n separada.

    Podemos crear una nueva tabla con un c√≥digo o atributo identificador para cada registro y a√±adir una clave ajena a modo de relaci√≥n 1:N.

    ![](images/04atributos-multivaluado.png "Atributo multivaluado"){ align="right" width="30%"}

    As√≠ pues, si tenemos un empleado que tiene muchos tel√©fonos mediante un atributo, generaremos dos tablas:

    `**EMPLEADO** (nif, nombre)`<br>
    `¬∑ PK: (nif)`
    <br>

    `**TELEFONO** (numero, dni*)`<br>
    `¬∑ PK: (numero)`<br>
    `¬∑ FK: (dni) ‚Üí EMPLEADO`<br>

    Si fuera un valor que pudiese compartirse entre varios empleados, como pudiera ser que un empleado tiene muchos cargos, y ese mismo cargo lo pueden tener varios empleados (pero no nos interesa a priori modelarlo conceptualmente como una entidad), podr√≠amos crear una clave primaria compuesta:

    `**CARGO** (cargo, dni*)`<br>
    `¬∑ PK: (cargo, dni)`<br>
    `¬∑ FK: (dni) ‚Üí EMPLEADO`<br>

--- 

### ‚ÜòÔ∏è Transformar relaci√≥n 1:1

En este caso, la clave ajena se pone en cualquier entidad y se a√±ade como clave alternativa/√∫nica (`UK`).

Como **norma general**, las relaciones con cardinalidad 1:1 **no generan una tabla**, lo que haremos ser√° que la clave primaria de una entidad pasar√° a formar parte de la tabla de la otra entidad, y pasar√° como un atributo.

La **participaci√≥n** de cada una de las entidades ser√° lo que **nos ayude a decidir** cu√°l ser√° la entidad que pasar√°
su clave primaria a la otra entidad.

> üî• **Excepci√≥n**: S√≥lo existe un caso donde una relaci√≥n con cardinalidad 1:1 genera una nueva tabla, y ser√°
cuando la participaci√≥n de las dos entidades sea de tipo (0,1) ‚Äì (0,1).


Veamos ejemplos de los distintos casos:

!!! success "Participaci√≥n (1,1)-(0,1)"

    En estos casos, la clave primaria de la entidad del lado (1,1) se propagar√≠a la entidad del lado (0,1), es decir, la clave primaria de la entidad USUARIO pasa a la entidad CANAL_YOUTUBE, quedando las tablas del modelo as√≠:

    ![](images/mias/1-1.a.png){ align="left" width="50%" }
    ![](images/mias/1-1.a.diagram.png){ align="right" width="40%" }
    

!!! success "Participaci√≥n (1,1)-(1,1)"

    Estos casos podemos resolverlos de dos maneras distintas:

    1. **Propagando la clave primaria de cualquiera de las entidades a la otra**. Da igual que entidad sea la que propague la clave. Este es la manera m√°s habitual de proceder.
    2. **La clave primaria de cada entidad se propaga en la otra** entidad, quedando algo as√≠:

    ![](images/mias/1-1.b.png){ align="left" width="40%" }
    ![](images/mias/1-1.b.diagram.png){ align="right" width="40%" }

    **Muy importante**: En este caso, la clave ajena deben ser clave √∫nica (`UK`), ya que la relaci√≥n es 1:1. Es decir, debe tener las restricciones de `NOT NULL` y `UNIQUE`.

!!! success "Participaci√≥n (0,1)-(0,1)"

    ![](images/mias/1-1.c.png){ align="center" width="40%" }

    En este caso tenemos dos opciones:

    1. Propagamos la clave primaria de una entidad a la otra entidad. Esta es la soluci√≥n m√°s usada.
    
    2. Crear una nueva tabla en la que almacenaremos la relaci√≥n entre las dos entidades. La clave primaria de esta entidad podr√≠a ser cualquiera de las claves primarias de la otras entidades.

    <div class="grid cards" markdown>

    -   ![](images/mias/1-1.c.diagram-1.png)
        <p class="text-center">Optci√≥n 1</p>

    -   ![](images/mias/1-1.c.diagram-2.png)
        <p class="text-center">Optci√≥n 2</p>

    </div>

<br><br>

### ‚ÜòÔ∏è Transformaci√≥n Relaciones Reflexivas

<u>Interrelaciones Reflexivas 1:M</u>

La clave primaria se almacena en la misma tabla como atributo.

<div class="grid cards" markdown>

-   ![](images/mias/reflexiva.a.png)
    <p class="text-center">Relaci√≥n reflexiva</p>

-   ![](images/mias/reflexiva.a.diagram.png)
    <p class="text-center">Transformaci√≥n: Relaci√≥n reflexiva</p>

</div>


<u>Interrelaciones Reflexivas N:M</u>

<div class="grid cards" markdown>

-   ![](images/mias/reflexiva.b.png){ width=90% }
    <p class="text-center">Relaci√≥n reflexiva N:M</p>

-   ![](images/mias/reflexiva.b.diagram.png){ width=70% }
    <p class="text-center">Transformaci√≥n: Relaci√≥n reflexiva N:M</p>

</div>


!!! question "Claves ajenas compuestas"

    ¬øY si nuestra entidad tiene una clave primaria compuesta? En este caso, la clave ajena tambi√©n deber√° compuesta.
    Esto se aplica a cualquier transformaci√≥n, 1:1, 1:N, N:M  o reflexivas.



### ‚ÜòÔ∏è Transformaci√≥n de relaci√≥n N:M

En el caso de las relaciones muchos a muchos, la relaci√≥n se traduce en una nueva tabla, cuya clave primaria se compone de las claves primarias referenciadas, y cada clave primaria es una clave ajena.

En caso del que **la interrelaci√≥n tuviera un atributo**, se convertir√≠a en un **atributo** de la nueva relaci√≥n. En algunos casos, sobre todo cuando las interrelaciones tienen atributos que denotan una **dimensi√≥n temporal** (generalmente atributos que recogen fechas, horas o intervalos de tiempo), estos deben formar **parte de la clave primaria** de la nueva relaci√≥n.


Para este ejemplo, tenemos una empresa de transportes, donde un conductor conduce varios autobuses, y luego un autobus lo conducen varios conductores en diferentes trayectos, dando lugar a una relaci√≥n muchos a muchos, donde en la relaci√≥n a√±adimos el atributo `trayecto`:

<div class="grid cards" markdown>

-   ![](images/04ejemplonm.png){ width=50% }
    <p class="text-center">Relaci√≥n N:M</p>

-   ![](images/mias/N-M.diagram.png){ width=70% }
    <p class="text-center">Transformaci√≥n: Relaci√≥n N:M</p>

</div>

!!! tip "El orden importa"

    Cuando pasamos una relaci√≥n uno a muchos o muchos a muchos de un modelo ER a un modelo relacional, primero crearemos las tablas que no tienen claves ajenas.

    En este caso, empezaremos por `CONDUCTOR` y `AUTOBUS`, definiendo sus claves primarias y atributos.

    A continuaci√≥n, crearemos la/s tabla/s que contiene claves ajenas a las tablas ya creadas, esto es, la tabla `CONDUCIR` que apunta a `CONDUCTOR` y `AUTOBUS`.


En este caso, el diagrama del modelo relacional se traduce en tres tablas conectadas, colocando el atributo de la relaci√≥n en la nueva tabla `CONDUCIR`. Destacar como la tabla tiene una clave primaria compuesta, donde de cada parte de la clave sale una clave ajena a cada una de las tablas que relaciona:

> üë®‚Äçüë©‚Äçüëß‚Äçüë¶ La cardinalidad 0..N en ambos lados de la relaci√≥n se cumple, ya que un conductor puede no conducir ning√∫n autob√∫s (0) o varios (N), y un autob√∫s puede no ser conducido por ning√∫n conductor (0) o varios (N). **¬øC√≥mo se refleja esto en las tablas?** Mediante la ausencia de registros en la tabla intermedia `CONDUCIR`.

Y comprobamos con datos c√≥mo s√≠ se cumplen las cardinalidades:

<div class="grid cards" markdown>

- `AUTOBUS`
    
    | matricula`*` | categoria |
    | --- | --- |
    | 1111ABC | normal |
    | 2222BCD | larga distancia |
    | 3333DEF | larga distancia |
    
- `CONDUCTOR`
    
    | nif`*` | nombre | experiencia |
    | --- | --- | --- |
    | 11111111A | Andr√©s Checa | 1 |
    | 22222222B | Jos√© Escrig | 2 |
    | 33333333B | Marina Fern√°ndez | 3 |
    
- `CONDUCIR`
    
    | conductorId`*` | autobusId`*` | trayecto |
    | --- | --- | --- |
    | 11111111A | 1111ABC | A |
    | 22222222B | 1111ABC | B |
    | 11111111A | 3333DEF | C |

</div>


#### N:M con dimensi√≥n temporal

Si la relaci√≥n tiene atributos de tipo fecha, ser√° necesario incluir al menos uno en la clave primaria.

Supongamos una empresa de alquiler de veh√≠culos, donde tenemos que un cliente puede alquilar el mismo veh√≠culo en fechas diferentes, o alquilar diferentes veh√≠culos. Claramente, un veh√≠culo lo pueden alquilar diferentes clientes en fechas diferentes. Para ello, creamos una relaci√≥n muchos a muchos, colocando la fecha de inicio y de finalizaci√≥n del alquiler en la propia relaci√≥n.

<div class="grid cards" markdown>

-   ![](images/04ejemplonm-fecha.png){ width=100% }
    <p class="text-center">Relaci√≥n N:M dimension temporal</p>

-   ![](images/mias/N-M.diagram-temporal.png){ width=100% }
    <p class="text-center">Transformaci√≥n: Relaci√≥n N:M dimension temporal</p>

</div>


Y la tabla que las relaciona con el atributo de fecha de inicio como parte de la clave primaria (de este modo, el cliente A puede alquilar el veh√≠culo X en d√≠as diferentes)



## ‚ùå Restricciones

Una vez visto como se transforman los atributos y las relaciones, vamos a ver algunas particularidades a la hora de aplicar restricciones sobre las cardinalidades.

### Cardinalidad m√≠nima 1

Cuando la cardinalidad m√≠nima es 1, independientemente de la cardinalidad m√°xima, estamos indicando que **s√≠ o s√≠ dicha clave ajena debe tener un valor**. Para cumplirla, √∫nicamente debemos marcar la clave ajena como valor no nulo (VNN).


!!! example "Usuario y Post"

    Un usuario puede escribir muchos Post y un Post debe ser escrito por un √∫nico usuario. Relaci√≥n 1-N, con cardinalidad (1,1)-(1,N).

    En este caso, para indicar la cardinalidad m√≠nima a 1 (un post debe tener un usuario), se indica el campo `usuarioId` (FK) en la tabla Post, como NN (Not Null)

    <div class="grid cards" markdown>

    -   ![](images/mias/CardinalidadMin.1N-11-erd.png){ width=100% }
        <p class="text-center">Cardinalidad m√≠nima a 1</p>

    -   ![](images/mias/CardinalidadMin.1N-11.png){ width=100% }
        <p class="text-center">Cardinalidad m√≠nima a 1</p>

    </div>


> üî• En los casos de cardinalidad m√≠nima en relaciones 1:1, que son las que cambian m√°s la transformaci√≥n ya lo vimos en los ejemplos de esos casos.


### Identificaci√≥n

En las restricciones de identificaci√≥n, la entidad d√©bil se identifica, completamente o en parte, con la entidad fuerte. Es decir, parte de la clave primaria de la entidad d√©bil son los atributos clave de la entidad fuerte. Es por ello, que la clave ajena debe formar parte de la clave primaria, la cual se define como una clave compuesta por la combinaci√≥n de la clave primaria de la entidad fuerte y la d√©bil:

![](images/04restric-id.png "Restricci√≥n de ID"){ width=50% }

Los atributos clave de la entidad d√©bil que no apuntan a la entidad fuerte se conocen como clave parcial. En el ejemplo anterior, `a0` ser√≠a la clave parcial de la entidad d√©bil `A`.

En el siguiente ejemplo, tenemos que cada sala se identifica por el cine al que pertenece por un n√∫mero de sala, el cual se reinicia por cada cine. Es decir, la sala 1 del cine IMF no es la misma tupla que la sala 1 del cine ABC:

<div class="grid cards" markdown>

-   ![](images/04ejemplo-id2.png){ width=100% }
    <p class="text-center">Ejemplo de restricci√≥n de IDdentificacion</p>

-   ![](images/mias/Ident.a.diagram.png){ width=100% }
    <p class="text-center">Ejemplo de restricci√≥n de IDdentificacion</p>

</div>

Las tablas de datos de ejemplo demuestran que aunque la entidad d√©bil repita n√∫mero, la clave de la entidad fuerte deshace la ambig√ºedad:

<div class="grid cards" markdown>

- `CINE`
    
    | codigo | nombre | direccion |
    | --- | --- | --- |
    | 1 | ABC | Elche |
    | 2 | IMF | Ondara |
    | 3 | Ode√≥n | Elche |

- `SALA`
    
    | numero | cineId`*` | aforo |
    | --- | --- | --- |
    | 1 | 1 | 50 |
    | 1 | 2 | 60 |
    | 1 | 3 | 70 |
    | 2 | 1 | 55 |

</div>


!!! tip "Ejemplo resuelto"

    Supongamos el diagrama ER que vimos en la unidad 2 al tratar las [restricciones de ID]. Vamos a obtener el modelo MR del mismo, teniendo en cuenta que la entidad `LINEA_PEDIDO` es una entidad d√©bil respecto a la relaci√≥n `CONTENER`, pero hace de entidad fuerte respecto a la relaci√≥n `TENER`:

    <div class="grid cards" markdown>

    -   ![](../02/images/02restriccion-id-fuerte.png){ width=100% }
        <p class="text-center">Restricci√≥n de ID</p>

    -   ![](images/mias/Ident.b.diagram.png){ width=100% }
        <p class="text-center">Restricci√≥n de IDdentificacion</p>

    </div>


    ¬øQu√© ha pasado con el atributo `PEDIDO.total`?



## üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Generalizaci√≥n y Especializaci√≥n (Jerarqu√≠as)

Existen varias soluciones para realizar el paso a tablas de una especializaci√≥n. La soluci√≥n que se elija en cada caso depender√° del tipo de especializaci√≥n que estemos resolviendo: total, parcial, inclusiva o exclusiva.

Las 3 soluciones posibles que podemos aplicar son las siguientes:

1. Crear **una √∫nica tabla** para la superclase. En este caso todos los atributos de las subclases se guardar√≠an en la superclase. 

   Adoptaremos esta soluci√≥n cuando los subtipos se diferencian en muy pocos atributos y las relaciones que los asocian con el resto de entidades del esquema sean las mismas para todos los subtipos. SOLO APLICA A ESPECIALIZACIONES PARCIALES.

2. Crear **tablas s√≥lo para las subclases**. En este caso los atributos de la superclase habr√≠a que guardarlos en cada una de las subclases. Elegiremos esta opci√≥n cuando existan muchos atributos distintos entre los subtipos. SOLO APLICA A ESPECIALIZACIONES TOTALES.

3. Crear **una tabla para cada una de las entidades**, tanto para la superclase como las subclases. En este caso las **subclases** tendr√≠an que **guardar la clave de la primaria de la superclase**. OPCI√ìN V√ÅLIDA PARA ESPECIALIZACIONES TOTALES Y PARCIALES.


!!! tip "En resumen"

    - **Si es `Parcial`** siempre hay que crear una tabla para la `superclase`, y las clases de los `subtipos` depender√° del n√∫mero de atributos comunes. Si la mayor√≠a son comunes habr√° pocos `propios` de cada subtipo, y por tanto, poco valores nulos o por defecto en la `superclase`. 
    
        - Poco comunes -> Crear subtipos.
        - Muchos comunes -> No crear subtipos.
    
    - **Si es `Total`**, siempre la `superclase` estar√° contenida el alg√∫n `subtipo`. La opci√≥n de crear o no la tabla para la `superclase` radica en el n√∫mero de campos comunes entre la superclase y los subtipos. 
    
        - Poco comunes -> Crear subtipos y crear tabla para la superclase.
        - Muchos comunes -> Crear tabla para la superclase y no crear subtipos.


!!! tipo "Exclusiva/Total"

    <figure markdown="span">
        <img src="images/jerarq/disj-total.er.png" width="80%">
        <figcaption>Exclusiva/Total</figcaption>
    </figure>

    En este caso ser√≠a adecuado utilizar la soluci√≥n 2 o 3. Tambi√©n ser√≠a posible utilizar la soluci√≥n 1, pero al tratarse de una especializaci√≥n exclusiva y total (las ocurrencias de la superclase est√°n en una subclase y s√≥lo en una) , tendr√≠amos muchas columnas con valores nulos.


    **Soluci√≥n 2: Crear una tabla para las subclases**

    En este caso no existenn relaciones entre ambas tablas, y la tabla en s√≠ misma indica el tipo.

    <figure markdown="span">
    <img src="images/jerarq/disj-total.er.digr2.png" width="80%">
    <figcaption>Soluci√≥n 2: Crear una tabla para las subclases</figcaption>
    </figure>


    **Soluci√≥n 3: Crear una tabla para todas las entidades**

    Todas las claves primarias de las subclases son claves ajenas que apuntan a la tabla de la superclase.

    <figure markdown="span">
    <img src="images/jerarq/disj-total.er.digr1.png" width="80%">
    <figcaption>Soluci√≥n 3: Crear una tabla para todas las entidades</figcaption>
    </figure>


!!! tipo "Solapada/(Total o Parcial)"

    Si es solapada, la mejor opci√≥n suele ser crear una √∫nica tabla para la superclase, ya que las ocurrencias pueden estar en varias subclases a la vez, y por tanto, no ser√≠a lo mejor crear tablas separadas para cada una de las subclases.

    **Soluci√≥n 1: Una √∫nica tabla**

    <figure markdown="span">
    <img src="images/jerarq/disj-total.er.digr3.png" width="80%">
    <figcaption>Soluci√≥n 1: Crear una tabla para todas las entidades</figcaption>
    </figure>


    Aunque tambi√©n ser√≠a posible crear tablas para las subclases, pero en este caso, habr√≠a que repetir las claves primarias en cada una de las tablas de las subclases, y adem√°s, habr√≠a que permitir valores nulos en las tablas de las subclases, ya que una ocurrencia podr√≠a no estar en alguna de ellas.

    **Soluci√≥n 2: Crear una tabla para las superclase y subclases**

    <figure markdown="span">
    <img src="images/jerarq/disj-total.er.digr1.png" width="80%">
    <figcaption>Soluci√≥n 2: Crear una tabla para las superclase y subclases</figcaption>
    </figure>


    **Soluci√≥n 3: Crear una tabla para todas las subclases**

    En este caso no existenn relaciones entre ambas tablas, y la tabla en s√≠ misma indica el tipo.

    <figure markdown="span">
    <img src="images/jerarq/disj-total.er.digr2.png" width="80%">
    <figcaption>Soluci√≥n 3: Crear una tabla para todas las subclases</figcaption>
    </figure>